const scope = new paper.PaperScope();
scope.setup(new paper.Size(100, 100));

type PathData = {
	id?: string;
	path?: string|null;
	color?: string;
	pattern?: string;
	line?: boolean;
	lineWeight?: number;
	opacity?: number;
};

const colorMap = new Map([
	[ Tincture.argent, '#f6f5e9' ],
	[ Tincture.azure, '#273ea5' ],
	[ Tincture.gules, '#ca271c' ],
	[ Tincture.or, '#e4ae0c' ],
	[ Tincture.purpure, '#893d8f' ],
	[ Tincture.sable, '#171826' ],
	[ Tincture.vert, '#20801e' ],
]);

function getPathForPart(part: Part, box: paper.Rectangle): paper.Path[] {
	const dev = part.device;
	let paths: paper.Path[] = [];
	const getEagleHead = () => {
		return [
			new paper.Path('M 258.582 125.685 C 257.275 124.414 256 123.158 254.767 121.918 C 266.163 125.286 275.507 136.13 297.611 113.576 C 292.959 107.208 284.153 104.001 277.426 103.058 C 279.228 104.942 280.364 107.671 280.364 110.706 C 280.364 116.388 276.391 120.994 271.492 120.994 C 266.592 120.994 262.621 116.388 262.621 110.706 C 262.621 109.048 262.958 107.48 263.56 106.092 C 258.69 109.697 255.386 115.359 251.614 118.678 C 231.946 97.977 227.837 82.805 297.611 86.036 C 329.456 87.513 346.906 76.818 346.906 76.818 C 346.906 76.818 347.852 90.269 339.134 93.949 C 349.809 98.309 367.12 110.547 370.64 126.553 L 358.282 127.005 C 370.056 139.815 390.775 160.718 399.128 188.667 C 399.128 188.667 397.154 195.843 389.283 199.346 C 410.391 233.021 370.779 248.376 410.838 251.871 C 410.838 251.871 380.602 287.39 353.687 256.503 C 349.746 283.011 364.13 298 364.13 298 C 364.13 298 328.297 297.94 314.808 251.022 C 303.403 272.984 283.797 274.749 271.876 298 C 259.54 278.752 276.953 252.383 279.352 248.47 C 279.352 248.47 237.468 257.235 231.29 233.621 C 286.412 241.71 301.036 168.787 258.582 125.685 Z'),
			new paper.Path('M 210.969 164.168 C 196.198 158.799 168.333 112.101 246.117 107.937 C 265.167 106.917 256.127 121.052 266.956 128.08 C 290.045 143.065 297.649 157.44 293.491 169.463 C 286.221 190.491 276.772 156.543 233.156 183.068 C 236.114 172.151 250.713 153.314 279.718 156.373 C 258.43 129.096 204.836 137.513 210.969 164.168 Z'),
			new paper.Path('M 285.17 149.682 C 205.372 140.071 234.548 183.126 194.716 178.617 C 227.629 203.122 211.954 160.137 291.616 163.306 L 285.17 149.682 Z'),
		];
	};
	const getLionRampantBackLeg = () => new paper.Path('M 313.356 492.677 C 308.436 499.786 329.501 520.388 327.464 536.46 C 327.415 536.843 327.363 537.229 327.306 537.617 C 335.285 553.758 336.232 571.774 336.232 571.774 C 336.232 571.774 328.298 574.264 322.592 571.132 C 330.729 580.84 333.801 600 333.801 600 C 333.801 600 317.682 598.321 313.539 595.684 C 326.808 604.541 319.563 621.665 319.563 621.665 C 314.777 615.108 305.86 612.31 302.55 614.383 C 308.63 620.009 312.566 633.927 296.614 637.987 C 301.832 627.842 293.5 623.598 285.507 622.621 C 278.67 632.253 273.206 638.903 271.331 640.314 C 268.907 642.137 265.967 643.408 262.707 644.192 C 264.657 647.614 265.879 650.978 265.747 653.211 C 265.218 662.105 255.574 662.988 247.264 660.776 C 243.28 659.715 241.128 653.937 240.821 647.778 C 240.449 650.955 239.366 654.066 238.042 656.802 C 233.7 665.775 217.664 661.021 213.898 652.997 C 211.781 648.484 216.244 640.305 221.239 634.994 C 221.199 634.964 221.158 634.935 221.118 634.905 C 218.062 638.267 214.841 641.195 212.195 642.618 C 204.026 647.011 193.543 631.825 195.793 623.508 C 196.656 620.321 201.951 617.81 208.251 616.37 C 204.531 616.691 200.772 616.511 197.823 615.703 C 188.365 613.11 188.203 595.081 194.895 590.777 C 200.911 586.91 220.305 599.833 223.028 607.732 C 229.072 605.023 235.331 604.071 235.331 604.071 C 235.331 604.071 286.516 552.778 285.343 529.975 C 284.742 518.299 246.518 467.138 258.415 445.503 C 270.323 423.849 314.628 406.999 347.945 398.759 C 361.075 407.223 367.496 417.793 374.881 426.64 C 368.001 441.023 358.564 462.562 352.571 484.836 C 333.263 486.189 318.289 485.546 313.356 492.677 Z');
	const getLionRampantBackClaws = () => (
		(new paper.Path('M 437.467 698.93 C 426.257 696.741 418.414 688.639 421.952 681.256 C 423.278 678.491 435.33 675.267 437.114 682.545 C 438.773 689.306 432.459 694.652 437.467 698.93 Z')
			.unite(new paper.Path('M 392.588 699.659 C 386.122 691.703 387.86 676.525 398.978 675.498 C 404.537 674.985 412.444 681.948 407.738 685.635 C 401.219 690.746 392.825 693.653 392.588 699.659 Z'))
			.unite(new paper.Path('M 359.576 683.338 C 356.335 673.085 363.343 659.885 374.387 658.904 C 379.496 658.45 388.92 676.058 379.483 673.493 C 369.814 670.864 361.944 677.233 359.576 683.338 Z'))
			.unite(new paper.Path('M 345.147 649.629 C 347.478 637.634 362.645 622.546 372.047 627.621 C 376.748 630.16 375.793 648.156 367.806 643.3 C 359.623 638.325 350.804 643.41 345.147 649.629 Z'))
			.unite(new paper.Path('M 263.974 674.709 C 252.764 672.52 244.921 664.418 248.459 657.035 C 249.785 654.27 261.837 651.046 263.621 658.324 C 265.28 665.085 258.966 670.431 263.974 674.709 Z'))
			.unite(new paper.Path('M 217.13 673.939 C 210.664 665.983 212.402 650.805 223.52 649.778 C 229.079 649.265 236.986 656.228 232.28 659.915 C 225.761 665.026 217.367 667.933 217.13 673.939 Z'))
			.unite(new paper.Path('M 184.631 650.756 C 181.39 640.503 188.398 627.303 199.442 626.322 C 204.551 625.868 213.975 643.476 204.538 640.911 C 194.869 638.282 186.999 644.651 184.631 650.756 Z'))
			.unite(new paper.Path('M 167.194 616.468 C 169.525 604.473 184.692 589.386 194.094 594.46 C 198.795 596.999 197.84 614.995 189.853 610.139 C 181.67 605.164 172.851 610.249 167.194 616.468 Z'))
		) as paper.Path
	);
	const getLionPassantBackLeg = () => new paper.Path('M 439.86 400 C 439.406 408.634 477.504 404.81 474.607 436.524 C 474.572 436.909 474.357 437.258 474.225 437.627 C 478.878 455.021 481.482 467.46 481.482 467.46 C 481.482 467.46 473.213 468.344 468.233 464.152 C 474.305 475.269 473.554 494.659 473.554 494.659 C 473.554 494.659 458.079 489.847 454.535 486.448 C 465.806 497.738 455.339 513.106 455.339 513.106 C 451.934 505.736 443.74 501.242 440.087 502.624 C 444.944 509.335 446.07 523.755 429.631 524.603 C 435.945 516.678 430.864 511.218 424.291 508.325 C 423.83 512.234 418.688 515.075 415.746 516.684 C 418.614 519.677 420.758 522.79 421.265 525.093 C 423.283 534.265 414.173 537.568 405.476 537.391 C 401.307 537.308 397.573 531.972 395.521 525.788 C 396.065 529.11 395.899 532.542 395.393 535.653 C 393.732 545.857 376.812 545.023 370.872 537.807 C 367.531 533.748 369.536 524.322 372.873 517.678 C 372.825 517.658 372.777 517.637 372.729 517.617 C 370.721 521.797 368.427 525.576 366.263 527.683 C 359.585 534.186 345.083 521.364 344.9 512.349 C 344.831 508.895 349.256 505.023 354.962 501.987 C 351.442 503.241 347.741 503.996 344.649 503.91 C 334.73 503.633 329.439 485.348 334.71 479.304 C 339.449 473.874 361.956 482.173 366.848 489.522 C 369.524 487.284 372.952 485.882 375.449 484.956 C 389.871 475.825 423.354 452.887 425.96 435.204 C 427.664 423.637 380.924 418.229 381.778 393.553 C 382.086 384.663 388.449 373.647 397.676 363.311 C 401.813 361.944 405.913 360.581 410.008 359.258 C 436.949 350.555 459.532 344.532 490.813 350.144 C 493.461 358.002 497.574 368.585 502.791 380.224 C 475.188 384.699 440.155 394.388 439.86 400 Z');
	const getLionPassantBackClaws = () => (
		(new paper.Path('M 424.627 545.141 C 412.132 544.633 401.966 537.673 404.156 529.716 C 404.977 526.734 417.201 521.671 420.692 528.719 C 423.938 535.268 418.328 541.596 424.627 545.141 Z')
			.unite(new paper.Path('M 376.665 552.655 C 368.006 545.634 366.574 530.11 378.274 527.397 C 384.123 526.041 394.111 531.848 389.866 536.265 C 383.985 542.389 375.617 546.581 376.665 552.655 Z'))
			.unite(new paper.Path('M 337.727 541.234 C 332.028 531.415 336.677 517.084 348.305 514.428 C 353.685 513.2 367.61 529.48 356.935 528.328 C 345.998 527.146 338.941 534.738 337.727 541.234 Z'))
			.unite(new paper.Path('M 314.94 509.523 C 314.838 497.11 327.825 479.646 339.008 483.329 C 344.599 485.172 347.481 503.409 337.863 499.734 C 328.009 495.969 319.657 502.414 314.94 509.523 Z'))
			.unite(new paper.Path('M 733.359 522.147 C 723.791 528.385 712.52 528.037 709.915 520.275 C 708.94 517.368 715.341 506.659 721.691 510.638 C 727.591 514.332 726.785 522.566 733.359 522.147 Z'))
			.unite(new paper.Path('M 701.669 553.934 C 691.488 552.73 682.161 540.631 689.422 532.149 C 693.053 527.908 703.576 527.395 702.768 533.319 C 701.652 541.527 697.655 549.46 701.669 553.934 Z'))
			.unite(new paper.Path('M 666.616 565.222 C 657.148 560.124 652.98 545.772 660.22 537.375 C 663.569 533.49 682.596 539.557 674.039 544.291 C 665.271 549.141 664.061 559.192 666.616 565.222 Z'))
			.unite(new paper.Path('M 632.781 551.09 C 626.097 540.861 626.468 519.47 636.748 516.561 C 641.89 515.108 653.741 528.684 644.628 530.764 C 635.292 532.896 632.507 542.687 632.781 551.09 Z'))
		) as paper.Path
	)
	const getWingForAttitude = (wingDirection: Attitude) => {
		if(wingDirection == Attitude.elevated) {
			return new paper.Path('M 392.15 251.295 C 477.38 285.292 488.612 232.53 480.147 198.404 C 476.93 185.434 453.44 158.986 453.44 158.986 C 462.135 157.12 468.814 157.99 472.275 158.459 C 470.222 148.694 469.243 141.793 467.687 133.108 C 458.709 83.008 708.723 41.556 708.723 41.556 C 708.723 41.556 705.922 81.689 695.307 87.254 C 652.602 94.597 584.521 108.359 540.266 127.58 C 567.97 117.053 644.251 118.411 694.585 121.875 C 701.055 134.339 698.038 150.253 691.925 160.443 C 649.092 156.777 585.892 151.543 540.828 158.583 C 570.114 157.787 639.005 172.546 686.057 188.834 C 688.061 203.63 684.863 222.415 675.233 229.365 C 640.071 214.28 583.953 202.251 537.186 187.634 C 572.968 205.579 629.203 233.076 663.344 259.907 C 665.551 275.734 656.796 293.448 644.508 294.776 C 615.498 270.947 580.725 254.513 541.795 228.701 C 569.897 254.906 603.184 283.72 628.167 318.634 C 620.894 335.312 614.092 345.103 592.233 352.972 C 577.922 328.485 561.589 302.035 544.771 277.749 C 555.683 300.919 566.6 333.38 575.748 364.887 C 564.707 382.09 552.254 386.509 537.764 385.246 C 531.46 358.729 520.723 331.374 512.271 304.629 C 515.783 328.996 520.136 360.413 519.925 392.141 C 509.646 402.645 496.991 404.795 480.95 402.68 C 482.775 376.202 480.75 353.757 477.019 327.282 C 473.158 351.366 471.889 375.808 462.513 405.859 C 454.119 412.343 441.637 414.122 426.047 409.342 C 433.034 385.851 436.805 363.515 436.506 338.598 C 427.997 359.775 423.347 384.243 408.797 409.855 C 388.057 416.481 375.92 410.722 369.906 403.688 L 392.15 251.295 Z');
		} else {
			return new paper.Path('M 389.978 260.072 C 501.545 259.468 416.506 106.319 485.072 111.305 C 515.318 113.504 532.959 148.64 571.047 148.676 C 563.696 157.855 553.917 160.159 545.991 159.647 C 623.105 260.117 682.898 477.452 682.898 477.452 C 666.217 482.26 639.138 475.775 625.256 468.843 C 616.327 432.578 574.656 287.904 536.939 216.677 C 553.626 277.693 595.285 422.278 600.881 465.644 C 589.853 467.55 569.715 465.179 558.21 456.744 C 551.305 398.236 535.956 313.741 519.509 258.429 C 521.818 305.571 536.756 394.734 539.743 454.382 C 528.635 455.842 521.308 450.968 508.905 442.143 C 508.802 388.102 499.965 322.153 491.925 284.397 C 494.904 326.32 496.397 387.024 495.346 438.819 C 481.278 440.468 474.311 439.602 465.166 428.988 C 467.769 386.329 466.854 340.92 463.837 308.904 C 461.187 342.918 459.179 381.858 453.275 422.808 C 444.907 422.282 433.876 417.178 426.017 411.102 L 434.099 312.519 L 414.526 406.204 C 402.403 404.369 382.797 391.807 378.615 387.036 L 389.978 260.072 Z');
		}
	};
	const addorseWing = (wing: paper.Path) => {
		let wing2 = wing.clone();
		wing2.translate(new paper.Point(-50, -30));
		return wing2.subtract(paperOffset.offset(wing, 8)) as paper.Path;
	};
	switch(dev.id) {
		case DeviceId.heater: {
			let path = new paper.Path([
				new paper.Segment(new paper.Point(-45, -20), new paper.Point(0, 50)),
				new paper.Segment(new paper.Point(-45, -50)),
				new paper.Segment(new paper.Point(45, -50),),
				new paper.Segment(new paper.Point(45, -20), undefined, new paper.Point(0, 50)),
				new paper.Segment(new paper.Point(0, 50)),
			]);
			path.closePath();
			paths.push(path);
			break;
		}
		case DeviceId.lozenge:
		case DeviceId.mascle: {
			let halfWidth = box.height * .4;
			let path = new paper.Path([
				new paper.Point(box.center.x, box.point.y),
				new paper.Point(box.center.x - halfWidth, box.center.y),
				new paper.Point(box.center.x, box.bottom),
				new paper.Point(box.center.x + halfWidth, box.center.y),
			]);
			path.closePath();
			if(dev.id == DeviceId.mascle) {
				let hole = path.clone();
				hole.scale(.6);
				path = path.subtract(hole) as paper.Path;
			}
			paths.push(path);
			break;
		}
		case DeviceId.mullet: {
			const pointCount = part.chargeDegree;
			let angle = 360 / pointCount;
			let points = [];
			for(let i=0; i<pointCount; i++) {
				let pt = new paper.Point(box.center.x, box.top);
				points.push(pt.rotate(angle * i, box.center));
			}
			const pointConnection = Math.ceil(pointCount/2) - 1;
			let lines: paper.Path.Line[][] = [];
			let incIndexForwardAndBack = (idx: number, amount: number) => {
				let previousPointIdx = idx - amount;
				if(previousPointIdx < 0) {
					previousPointIdx += pointCount;
				}
				let nextPointIdx = (idx + amount) % pointCount;
				return [previousPointIdx, nextPointIdx];
			}
			for(let i=0; i<pointCount; i++) {
				let [previousPointIdx, nextPointIdx] = incIndexForwardAndBack(i, pointConnection);
				lines.push([
					new paper.Path.Line(points[i], points[previousPointIdx]),
					new paper.Path.Line(points[i], points[nextPointIdx]),
				]);
			}
			let starPoints = [];
			for(let i=0; i<pointCount; i++) {
				let adjacentPoints = incIndexForwardAndBack(i, 1);
				let currentLines = lines[i];
				let adjacentLines = adjacentPoints.map(idx => lines[idx]);
				let priorAdjacent = currentLines[0].getCrossings(adjacentLines[0][1]).pop()!.point;
				let nextAdjacent = currentLines[1].getCrossings(adjacentLines[1][0]).pop()!.point;
				starPoints.push(priorAdjacent, points[i], nextAdjacent);
			}
			let path = new paper.Path(starPoints);
			path.closePath();
			paths.push(path);
			break;
		}
		case DeviceId.heart: {
			let path = new paper.Path([
				new paper.Segment(
					new paper.Point(box.center.x, box.bottom),
					new paper.Point(box.width, -box.height*.6),
					new paper.Point(-box.width, -box.height*.6),
				),
				new paper.Segment(
					new paper.Point(box.center.x, box.top + box.height*.3),
					new paper.Point(-box.width*.2, -box.height*.4),
					new paper.Point(box.width*.2, -box.height*.4),
				),
			]);
			path.closePath();
			paths.push(path);
			break;
		}
		case DeviceId.crescent: {
			let circle = new paper.Path.Circle(box.center, box.width/2);
			let miniCircle = new paper.Path.Circle(new paper.Point(box.center.x, box.center.y - box.height*.2), box.width*.35);
			paths.push(circle.subtract(miniCircle) as paper.Path);
			break;
		}
		case DeviceId.billet: {
			paths.push(new paper.Path.Rectangle(new paper.Rectangle(new paper.Point(0,0), new paper.Size(20, 40))));
			break;
		}
		case DeviceId.escutcheon: {
			let root = part;
			while(root.parent) {
				root = root.parent;
			}
			return getPathForPart(root, box);
		}
		case DeviceId.tower: {
			paths.push((new paper.Path('M 75 150 L 100 150 L 100 175 L 125 175 L 125 150 L 150 150 L 150 175 L 175 175 L 175 150 L 200 150 L 200 175 L 225 175 L 225 150 L 250 150 L 250 200 L 75 200 L 75 150 Z')
				.unite(new paper.Path('M 200 412.5 C 200 391.79 183.211 375 162.5 375 C 141.79 375 125 391.79 125 412.5 L 125 440.744 L 50 440.744 L 50 400 C 100 350 100 260 100 260 L 79.628 209.256 L 245.372 209.256 L 225 260 C 224.981 259.98 225 350 275 400 L 275 440.744 L 200 440.744 L 200 412.5 Z'))
				.unite(new paper.Path('M 275 475 L 200 475 L 200 450 L 275 450 L 275 475 Z'))
				.unite(new paper.Path('M 125 475 L 50 475 L 50 450 L 125 450 L 125 475 Z'))
				.subtract(new paper.Path('M 150 272.5 L 150 310 L 175 310 L 175 272.5 C 175 265.596 169.404 260 162.5 260 C 155.596 260 150 265.596 150 272.5 Z'))
			) as paper.Path);
			break;
		}
		case DeviceId.crown: {
			paths.push(new paper.Path('M 25 300 C 25.011 299.988 75 325 68.35 357.799 C 67.502 360.719 67.048 363.807 67.048 367 C 67.048 385.187 81.782 399.933 99.964 399.952 L 100 400 L 100.024 399.952 C 118.212 399.939 132.952 385.191 132.952 367 C 132.952 359.59 130.506 352.75 126.377 347.246 C 125 325 149.972 274.793 150 275 C 150.187 274.447 175 325 173.623 347.246 C 169.494 352.75 167.048 359.59 167.048 367 C 167.048 385.191 181.788 399.939 199.976 399.952 L 200 400 L 200.036 399.952 C 218.218 399.933 232.952 385.187 232.952 367 C 232.952 363.807 232.498 360.719 231.65 357.799 C 225 325 274.955 299.928 275 300 L 254.894 440.744 L 45.106 440.744 Z').unite(new paper.Path('M 250 475 L 50 475 L 46.429 450 L 253.571 450 Z')) as paper.Path);
			break;
		}
		case DeviceId.key: {
			paths.push((new paper.Path('M 162.5 478 C 162.5 505.614 140.114 528 112.5 528 C 84.886 528 62.5 505.614 62.5 478 C 62.5 454.702 78.435 435.126 100 429.575 L 100 325 L 50 325 L 50 300 L 75 300 L 75 275 L 50 275 L 50 250 L 100 250 L 100 235.642 L 125 235.642 L 125 429.575 C 146.565 435.126 162.5 454.702 162.5 478 Z')
				.subtract(new paper.Path('M 112.5 453 C 98.693 453 87.5 464.193 87.5 478 C 87.5 491.807 98.693 503 112.5 503 C 126.307 503 137.5 491.807 137.5 478 C 137.5 464.193 126.307 453 112.5 453 Z'))
			) as paper.Path);
			break;
		}
		case DeviceId.trefoil: {
			paths.push(new paper.Path('M 250 461 C 250 467.904 244.404 473.5 237.5 473.5 C 230.596 473.5 225 467.904 225 461 L 230.533 418.95 C 222.096 428.472 209.775 434.474 196.053 434.474 C 170.618 434.474 150 413.855 150 388.421 C 150 362.987 170.618 342.368 196.053 342.368 C 197.183 342.368 198.304 342.409 199.414 342.489 C 194.382 335.108 191.44 326.187 191.44 316.579 C 191.44 291.145 212.058 270.526 237.492 270.526 C 262.927 270.526 283.545 291.145 283.545 316.579 C 283.545 326.187 280.602 335.109 275.569 342.49 C 276.685 342.41 277.811 342.368 278.947 342.368 C 304.382 342.368 325 362.987 325 388.421 C 325 413.855 304.382 434.474 278.947 434.474 C 265.225 434.474 252.904 428.472 244.467 418.95 Z'));
			break;
		}
		case DeviceId.sword: {
			paths.push(new paper.Path('M 75 150 C 75 75 99.984 24.943 100 25 C 100.002 24.988 125 75 125 150 L 125 425 L 75 425 L 75 150 Z'));
			paths.push(new paper.Path('M 25 407.143 C 35.714 421.429 89.285 421.429 100 407.143 C 110.715 421.429 164.286 421.429 175 407.143 L 164.286 450 L 116.309 450 L 116.309 556.052 C 121.631 560.636 125 567.425 125 575 C 125 588.807 113.807 600 100 600 C 86.193 600 75 588.807 75 575 C 75 567.425 78.369 560.637 83.69 556.053 L 83.69 450 L 35.714 450 Z'));
			break;
		}
		case DeviceId.lion: {
			// head
			const regardant = part.attitudes[1] == Attitude.regardant;
			let main: paper.Path;
			let armed: paper.Path;
			let langued: paper.Path;
			if(part.attitudes[1] != Attitude.guardant) {
				main = (new paper.Path('M 316.783 70.198 C 330.661 80.501 330.165 100 312.687 101.776 C 336.262 113.13 340.982 136.495 365.093 125.91 C 365.093 146.866 345.12 151.068 338.977 150 C 385.69 175 351.628 221.347 396.905 242.095 C 377.776 253.159 365.093 253.159 342.404 230.524 C 342.998 263.211 385.417 277.655 356.899 316.784 C 354.84 286.904 316.944 296.636 312.116 265.35 C 316.142 293.542 291.196 335.444 276.887 346.669 C 290.158 317.679 271.965 288.705 268.397 277.213 C 263.285 307.466 231.192 293.274 226.711 328.836 C 210.066 296.726 213.875 275 213.875 275 C 213.875 275 188.757 290.016 183.739 263.414 C 206.038 268.848 190.314 240.244 200 225 C 241.526 220.127 262.089 200 260.85 181.183 C 250 216.494 179.945 219.813 167.078 218.684 C 165.815 228.778 151.012 235.114 155.051 243.744 C 144.91 238.523 138.019 225.722 143.794 214.456 C 138.628 211.906 132.787 200 134.614 198.093 C 148.601 183.495 160.688 186.73 174.218 189.535 C 232.631 201.642 191.606 111.662 159.401 150.496 C 152.927 158.302 126.305 165.222 121.029 161.335 C 116.126 157.722 110.726 149.453 110.726 149.453 C 110.726 149.453 127.087 143.074 127.114 130.722 C 120.426 143.222 107.268 144.108 107.268 144.108 C 101.453 139.41 98.685 129.558 100.604 123.412 C 102.529 117.244 115.156 110.095 127.922 116.363 C 127.922 116.363 141.879 114.401 148.801 111.662 C 153.845 79.849 200.594 76.623 200.594 76.623 C 211.462 67.522 205.45 55.201 193.115 60.151 C 199.053 47.072 233.149 46.404 246.804 59.473 C 243.007 64.518 238.883 70.63 234.552 77.993 C 250.691 61.375 266.972 54.204 278.655 50.331 C 280.365 53.809 284.208 64.852 283.754 75.934 C 296.53 74.356 318.026 87.582 316.783 70.198 Z')
					.subtract(new paper.Path('M 213.346 109.342 C 207.659 101.314 199.809 95.033 192.331 94.865 C 195.96 96.196 198.248 99.956 197.593 103.909 C 196.851 108.381 192.626 111.404 188.155 110.664 C 183.683 109.922 180.66 105.697 181.4 101.226 C 181.496 100.654 181.647 100.107 181.849 99.588 C 179.958 101.597 178.207 104.304 176.654 107.816 C 183 120.19 199.66 120.08 213.346 109.342 Z'))
					.subtract(new paper.Path('M 272.648 60.342 C 264.754 63.765 252.39 73.796 245.328 85.831 C 264.399 83.344 277.946 71.994 272.648 60.342 Z'))
				) as paper.Path
				langued = new paper.Path('M 211.315 177.92 C 84.391 161.454 136.698 225 92.692 207.448 C 100 225 125 228.028 137.166 200 L 194.247 194.678 L 211.315 177.92 Z').subtract(main) as paper.Path;
				armed = (new paper.Path('M 144.072 154.315 C 143.984 154.383 137.338 166.889 139.903 177.293 C 129.468 172.808 123.354 159.426 123.391 159.429 Z')
					.unite(new paper.Path('M 163.379 191.944 C 160.909 190.842 161.631 176.725 165.286 169.47 C 169.799 183.493 180.193 193.066 181.879 193.223 Z'))
					.subtract(main)
				) as paper.Path;
				if(regardant) {
					const flipPoint = new paper.Point(290, 0);
					main.scale(-1, 1, flipPoint);
					armed.scale(-1, 1, flipPoint);
					langued.scale(-1, 1, flipPoint);
				}
			} else {
				main = (new paper.Path('M 333.729 170.905 C 332.61 178.532 337.32 210.278 357.39 194.274 C 364.361 204.513 351.847 221.473 337.128 218.688 C 346.969 244.853 383.787 273.008 343.602 300 C 343.932 291.62 338.107 275.16 338.107 275.16 C 338.107 275.16 336.494 333.352 325.14 343.273 C 325.14 343.273 308.403 332.151 300 310.435 C 307.036 340.566 276.112 387.89 264.361 388.252 C 275.87 357.226 244.35 356.268 238.54 306.283 C 234.797 313.292 230.02 335.634 238.12 354.032 C 200 333.975 224.429 282.807 203.571 280.351 C 196.682 279.54 184.376 284.958 195.556 302.984 C 160.085 290.782 159.783 226.686 188.008 206.601 C 174.189 208.655 165.872 200.763 165.872 200.763 C 173.983 173.633 186.24 187.701 188.987 139.644 C 172.857 119.667 178.695 89.327 178.695 89.327 C 178.695 89.327 202.988 86.954 209.88 94.583 C 217.691 78.474 232.874 75.886 232.874 75.886 C 232.874 75.886 234.222 83.367 239.12 85.204 C 247.278 52.792 269.849 73.475 263.736 53.909 C 283.52 55.819 307.228 67.738 314.002 94.162 C 321.393 87.043 344.778 89.327 344.778 89.327 C 344.778 89.327 350.461 118.863 335.12 138.839 C 335.85 147.741 335.574 158.336 333.729 170.905 Z')
					.subtract(new paper.Path('M 244.067 183.447 C 227.81 183.447 226.349 166.402 226.259 163.431 C 226.259 204.048 226.387 224.357 261.875 224.357 C 297.489 224.357 297.489 203.902 297.489 162.992 C 297.489 162.992 297.489 183.447 279.682 183.447 L 244.067 183.447 Z'))
					.subtract(new paper.Path('M 226.259 162.992 C 226.254 162.992 226.25 163.148 226.259 163.431 C 226.259 163.285 226.259 163.139 226.259 162.992 Z'))
					.subtract(new paper.Path('M 273.485 151.91 C 285.1 151.91 285.1 147.562 285.1 138.861 C 277.358 147.562 269.616 147.562 261.874 147.562 C 254.132 147.562 246.39 147.562 238.648 138.861 C 238.648 147.562 238.641 151.91 250.256 151.91 C 261.87 151.91 254.132 164.953 261.874 164.955 C 269.616 164.958 261.87 151.91 273.485 151.91 Z'))
					.subtract(new paper.Path('M 310.191 115.491 C 301.74 111.265 295.747 110.735 291.501 112.104 C 293.978 113.257 295.695 115.767 295.695 118.68 C 295.695 122.682 292.45 125.927 288.448 125.927 C 285.898 125.927 283.654 124.609 282.362 122.618 C 281.175 126.54 281.18 129.985 281.2 129.986 C 310.191 129.986 310.191 115.491 310.191 115.491 Z'))
					.subtract(new paper.Path('M 242.544 129.986 C 242.563 129.986 242.569 126.54 241.381 122.618 C 240.089 124.61 237.845 125.928 235.295 125.928 C 231.293 125.928 228.048 122.682 228.048 118.68 C 228.048 115.768 229.766 113.257 232.243 112.105 C 227.996 110.735 222.003 111.266 213.552 115.491 C 213.552 115.491 213.552 129.986 242.544 129.986 Z'))
					.subtract(new paper.Path('M 239.416 237.047 C 235.053 267.087 260.421 266.672 257.184 280.01 C 291.881 267.933 284.121 236.639 284.108 236.636 C 285.015 237.253 278.373 260.241 261.651 267.345 C 260.321 250.454 249.012 260.425 239.416 237.047 Z'))
				) as paper.Path;
				langued = new paper.Path('M 244.067 183.447 C 244.067 183.447 244.067 224.357 261.875 244.812 C 279.682 224.357 279.682 183.447 279.682 183.447 C 261.875 183.447 261.559 168.289 261.875 168.268 C 261.885 168.269 261.875 183.447 244.067 183.447 Z');
				armed = (new paper.Path('M 283.326 200.471 C 283.326 200.471 283.01 193.773 281.629 183.361 C 286.227 182.946 289.491 181.059 291.81 178.59 C 287.38 190.918 283.327 200.472 283.326 200.471 Z')
					.unite(new paper.Path('M 240.418 200.471 C 240.417 200.472 236.367 190.924 231.939 178.602 C 234.261 181.065 237.526 182.945 242.115 183.361 C 240.734 193.772 240.418 200.471 240.418 200.471 Z'))
					.unite(new paper.Path('M 243.776 201.249 C 243.776 201.249 244.225 210.047 246.509 222.551 C 242.593 221.426 239.435 219.777 236.888 217.603 C 240.518 208.337 243.775 201.248 243.776 201.249 Z'))
					.unite(new paper.Path('M 279.968 201.249 C 279.969 201.248 283.227 208.338 286.858 217.607 C 284.31 219.78 281.151 221.429 277.235 222.552 C 279.519 210.048 279.968 201.249 279.968 201.249 Z'))
				) as paper.Path;
			}
			// body
			switch(part.attitudes[0]) {
				case Attitude.rampant: {
					let rampantBody = (new paper.Path('M 54.344 281.814 C 48.848 287.181 32.151 283.932 31.635 276.197 C 31.336 271.708 33.804 264.157 37.971 258.696 C 33.214 261.826 28.453 263.985 25.898 263.801 C 17.854 263.217 11.042 247.406 17.491 241.547 C 20.681 238.647 27.518 236.372 34.337 235.855 C 28.385 235.243 23.228 233.886 21.403 232.021 C 15.446 225.928 21.882 208.767 31.659 209.171 C 37.679 209.418 47.583 213.533 53.835 219.069 C 49.729 213.008 46.777 206.472 47.376 203.481 C 48.966 195.574 65.317 190.246 70.32 197.38 C 73.935 202.532 77.097 215.566 75.07 224.237 C 78.615 225.618 82.357 227.565 86.275 230.167 C 185.196 296.024 267.32 202.139 288.046 230.27 L 323 213.049 C 390.869 242.594 453.09 333.851 475.276 395.955 C 484.494 410.876 516.391 458.252 529.972 451.811 C 563.603 435.86 431.601 280.885 480.568 238.857 C 507.956 215.348 548.804 237.141 555.51 250.08 C 586.799 248.877 585.793 278.496 600 260.588 C 604.35 263.877 605.791 283.582 587.021 278.849 C 620.678 293.117 612.246 329.312 645.221 334.746 C 608.675 342.105 591.333 332.595 580.341 311.19 C 581.215 320.338 587.542 332.748 573.717 343.484 C 573.717 309.598 525.034 300 536.598 264.328 C 536.598 264.328 513.31 242.536 500 256.503 C 491.323 265.608 500 300 519.676 329.111 C 542.627 332.618 559.58 345.496 558.06 346.512 C 558.065 346.376 548.137 343.154 542.275 347.407 C 569.453 352.943 566.868 376.625 584.525 382.108 C 568.985 384.623 562.877 371.034 552.27 373.266 C 569.33 381.013 587.968 403.302 585.796 415.122 C 580.049 404.03 567.618 395.961 556.815 400 C 571.247 406.505 583.141 429.873 564.874 434.301 C 571.839 423.209 562.416 417.057 555.289 420.339 C 562.788 449.685 560.433 469.108 545.125 478.318 C 527.239 489.079 488.448 468.191 478.668 461.943 C 464.406 496.328 426.083 511.859 431.231 525 C 436.228 537.754 475 529.78 483.773 543.277 C 485.044 545.233 485.673 548.202 485.78 551.939 C 490.741 555.826 502.845 571.709 503.488 586.812 C 503.488 586.812 490.13 586.491 485.798 585.322 C 489.775 588.125 502.407 602.229 502.008 610.797 C 499.842 611.804 488.658 609.411 483.074 608.377 C 488.953 616.536 495.199 624.084 491.781 639.752 C 487.737 633.527 479.042 625.567 473.67 626.168 C 484.713 635.867 485.692 650.798 467.847 656.114 C 475.353 644.453 464.118 640.148 461.172 640.11 C 456.093 652.433 451.752 661.412 450 663.267 C 446.548 666.925 441.441 669.322 435.615 670.614 C 438.753 674.703 440.716 679.691 439.572 682.798 C 437.245 689.122 421.481 689.604 417.284 683.426 C 415.596 680.94 415.465 677.12 416.408 673.506 C 414.97 677.966 412.492 682.253 410.32 684.675 C 406.538 688.892 394.209 686.386 391.493 678.858 C 390.445 675.954 391.907 671.619 394.622 667.624 C 392.413 670.346 389.727 672.694 387.073 674.285 C 379.082 679.077 369.302 665.652 371.666 657.65 C 372.745 654 378.31 650.823 384.12 649.181 C 379.685 649.699 375.005 649.227 371.836 647.488 C 363.668 643.005 363.406 625.635 371.507 623.641 C 378.703 621.869 393.857 632.659 396.195 639.777 C 401.873 635.779 408.406 633.612 408.406 633.612 C 408.406 633.612 444.444 578.466 438.535 567.349 C 433.582 558.03 373.192 567.091 361.424 544.257 C 346.143 514.607 375 450.001 387.951 425 C 375 411.383 358.646 384.133 312.374 375 C 307.463 374.03 302.846 372.878 298.507 371.562 C 301.833 379.435 300 386.92 300 386.92 C 300 386.92 280.014 393.914 270.49 391.391 C 274.771 396.617 279.26 408.511 278.594 408.386 C 278.594 408.386 258.223 414.148 246.427 412.083 C 251.061 416.746 251.5 425.77 250.762 425.701 C 250.808 425.706 241.626 430.44 226.131 430.301 C 214.954 430.989 159.631 462.118 159.688 462.115 C 154.332 465.885 149.364 468.567 144.794 470.335 C 147.916 475.334 149.925 480.631 149.176 483.317 C 147.085 490.805 130.838 495.996 126.475 489.3 C 124.408 486.131 122.922 480.236 122.923 474.41 C 120.878 481.59 117.507 488.238 114.68 489.378 C 107.697 492.191 93.81 481.005 96.451 472.654 C 97.887 468.11 102.699 461.649 108.241 457.636 C 101.657 461.827 93.769 464.827 90.417 463.794 C 82.711 461.416 79.057 444.61 86.659 440.352 C 90.381 438.266 97.124 436.907 103.496 437.207 C 96.8 435.201 90.027 431.753 87.819 429.142 C 82.395 422.723 87.971 405.329 96.752 405.615 C 103.341 405.828 114.258 414.365 118.1 424.717 C 119.576 423.69 121.21 422.813 123.002 422.116 C 186.436 397.47 218.994 353.659 236.156 324.439 C 230.46 322.319 225.701 319.893 223.939 317.342 C 221.844 324.519 214.017 334.453 213.78 333.851 C 213.78 334.33 195.898 330.383 191.691 322.05 C 190.161 328.898 182.425 335.038 182.425 335.038 C 182.425 335.038 166.504 330.298 162.103 320.89 C 161.975 325.678 152.736 332.33 152.765 331.256 C 142.976 326.703 115.874 296.742 65.916 271.002 C 62.629 271.015 59.642 270.718 56.94 270.164 C 57.014 275.334 56.15 280.05 54.344 281.814 Z')
						.subtract(paperOffset.offset(main, 7 * (regardant ? -1 : 1), {join:'round'}))
						.unite(getLionRampantBackLeg())
					) as paper.Path;
					let rampantClaws = (getLionRampantBackClaws()
						.unite(new paper.Path('M 150.608 510.513 C 139.713 508.87 130.629 498.619 132.273 487.954 C 132.889 483.96 143.363 478.003 146.638 487.863 C 149.681 497.023 145.007 505.209 150.608 510.513 Z'))
						.unite(new paper.Path('M 94.145 507.832 C 88.717 498.242 91.61 478.731 102.159 476.462 C 107.434 475.328 114.298 483.527 109.565 488.637 C 103.006 495.718 94.865 500.151 94.145 507.832 Z'))
						.unite(new paper.Path('M 63.685 470.669 C 63.141 459.664 73.93 445.528 85.546 444.511 C 90.921 444.041 95.82 462.953 86.819 460.173 C 77.597 457.323 67.777 464.129 63.685 470.669 Z'))
						.unite(new paper.Path('M 61.968 419.045 C 68.413 408.663 87.953 399.955 94.936 408.042 C 98.427 412.086 91.135 428.566 85.397 421.188 C 79.518 413.628 69.467 415.245 61.968 419.045 Z'))
						.unite(new paper.Path('M 45.204 304.04 C 35.599 298.64 30.74 285.834 36.059 276.446 C 38.051 272.929 49.957 271.073 49.523 281.453 C 49.12 291.098 41.847 297.094 45.204 304.04 Z'))
						.unite(new paper.Path('M -2.126 268.151 C -1.506 257.149 11.475 242.3 21.576 246.094 C 26.627 247.992 27.969 258.601 21.225 260.34 C 11.878 262.751 2.633 262.079 -2.126 268.151 Z'))
						.unite(new paper.Path('M -3.413 216.638 C 3.935 208.426 21.544 205.953 30.523 213.393 C 34.677 216.835 24.871 233.733 20.422 225.429 C 15.864 216.92 4.094 214.862 -3.413 216.638 Z'))
						.unite(new paper.Path('M 36.951 178.917 C 47.827 177.147 65.128 186.618 63.603 197.3 C 62.84 202.641 47.276 207.728 49.034 198.473 C 50.836 188.99 43.907 182.253 36.951 178.917 Z'))
					) as paper.Path;
					main = rampantBody.unite(main) as paper.Path;
					armed = rampantClaws.unite(armed) as paper.Path;
					break;
				}
				case Attitude.passant: {
					let passantBody = (new paper.Path('M 325.869 220.652 C 379.644 217.801 405.889 244.24 465.979 249.405 C 507.659 252.986 543.495 238.828 578.721 255.307 C 614.043 263.057 674.419 258.269 673.908 244.223 C 672.553 207.026 495.51 260.324 494.123 183.538 C 493.471 147.45 540.035 123.995 552.082 118.089 C 563.348 88.875 590.295 99.34 579.463 79.211 C 584.204 76.515 602.873 82.983 591.104 98.352 C 617.518 73.078 647.43 95.134 665.458 66.994 C 657.768 103.472 642.177 115.641 618.17 117.274 C 626.918 120.088 640.818 119.184 645.214 136.127 C 614.088 122.729 586.025 163.651 557.831 138.926 C 557.831 138.926 515.461 157.409 514.332 179.545 C 513.692 192.106 522.616 211.732 557.134 205.168 C 569.43 185.475 587.961 174.994 588.294 176.792 C 588.171 176.734 581.286 184.578 582.875 191.645 C 598.705 168.87 619.436 180.607 631.453 166.557 C 627.619 181.825 612.723 182.062 610.579 192.688 C 624.44 180.08 652.281 171.774 662.279 178.442 C 649.819 179.335 637.493 187.563 636.931 199.083 C 648.612 188.399 674.779 186.713 671.624 205.242 C 664.19 194.459 654.813 200.682 655.01 208.526 C 684.93 213.241 699.361 224.728 699.999 242.583 C 701.096 273.244 643.297 290.587 607.469 293.245 C 620.672 328.004 595.544 392.366 608.312 398.27 C 620.745 404.019 643.216 371.432 658.889 375.104 C 661.16 375.636 663.669 377.344 666.332 379.968 C 672.603 379.341 692.332 382.431 703.248 392.888 C 703.248 392.888 693.383 401.9 689.446 404.054 C 694.257 403.326 713.136 404.766 718.777 411.227 C 717.91 413.453 708.181 419.465 703.434 422.582 C 713.325 424.404 723.057 425.53 731.432 439.206 C 724.205 437.511 712.42 437.782 708.957 441.933 C 723.641 441.293 734.68 451.394 725.477 467.58 C 722.826 453.968 711.736 458.635 709.583 460.646 C 714.445 473.057 716.903 482.624 717.543 485.094 C 720.335 495.872 715.764 498.844 712.452 503.809 C 717.547 504.589 722.416 506.831 723.74 509.866 C 726.437 516.041 715.391 527.298 708.086 525.743 C 705.147 525.116 702.409 522.449 700.588 519.188 C 702.637 523.402 703.815 528.212 703.923 531.463 C 704.111 537.125 693.477 543.848 686.306 540.293 C 683.54 538.922 681.596 534.781 680.791 530.018 C 681.08 533.511 680.766 537.065 679.951 540.05 C 677.499 549.039 661.148 546.116 657.317 538.704 C 655.57 535.322 657.389 529.178 660.447 523.972 C 657.604 527.415 653.899 530.313 650.408 531.25 C 641.409 533.666 629.2 521.309 633.668 514.263 C 637.636 508.004 656.043 505.307 662.656 508.827 C 663.988 502.012 666.996 492.47 666.996 492.47 C 666.996 492.47 654.849 427.723 642.89 423.787 C 632.866 420.487 595.542 468.819 571.245 460.479 C 539.696 449.649 504.951 370.214 496.999 343.204 C 426.316 329.018 389.345 370.201 316.412 372.299 C 313.675 374.661 300.06 386.077 291.309 387.232 C 297.256 390.437 305.931 399.73 305.268 399.867 C 305.268 399.867 288.619 412.944 276.923 415.521 C 282.982 418.071 286.82 426.249 286.112 426.466 C 286.156 426.454 279.465 434.324 265.081 440.088 C 255.007 444.975 215.302 495.49 215.278 495.541 C 213.054 500.373 208.738 504.495 203.323 507.752 C 207.867 510.798 211.536 515.142 211.443 518.644 C 211.257 525.771 195.583 531.558 189.265 526.772 C 186.724 524.845 185.293 521.057 185.01 517.114 C 185.083 522.072 184.052 527.207 182.693 530.367 C 180.327 535.871 167.089 537.504 161.799 530.865 C 159.759 528.304 159.753 523.463 161.122 518.542 C 159.829 522.015 157.929 525.274 155.803 527.763 C 149.405 535.259 135.013 525.08 134.666 516.256 C 134.509 512.231 139.02 507.173 144.299 503.571 C 140.019 505.582 135.156 506.683 131.382 506.004 C 121.651 504.254 115.48 486.916 122.94 482.19 C 129.568 477.991 148.462 483.721 153.231 490.074 C 157.576 484.153 163.404 479.782 163.404 479.782 L 163.445 479.794 C 197.021 447.005 217.988 391.747 227.697 360.905 C 219.296 356.378 214.136 350.861 210.542 345.715 C 207.109 352.357 197.522 360.606 197.405 359.969 C 197.313 360.44 180.52 353.137 177.989 344.151 C 175.174 350.579 166.404 355.122 166.404 355.122 C 166.404 355.122 151.688 347.417 149.172 337.339 C 148.128 342.014 137.786 346.77 138.02 345.722 C 129.286 339.377 108.432 304.775 64.337 269.932 C 61.108 269.314 58.234 268.451 55.688 267.389 C 54.769 272.477 53.017 276.94 50.907 278.325 C 44.483 282.538 28.719 276.148 29.696 268.457 C 30.262 263.993 34.133 257.055 39.27 252.495 C 34 254.655 28.914 255.861 26.442 255.19 C 18.659 253.075 15.006 236.251 22.458 231.737 C 26.145 229.503 33.292 228.581 40.084 229.381 C 34.36 227.639 29.558 225.319 28.125 223.138 C 23.446 216.016 33.053 200.407 42.572 202.679 C 48.433 204.075 57.364 210.014 62.438 216.646 C 59.571 209.91 57.927 202.93 59.088 200.108 C 62.165 192.653 79.235 190.559 82.776 198.52 C 85.336 204.27 85.94 217.668 82.288 225.79 C 85.503 227.824 88.803 230.454 92.149 233.759 C 165.447 306.318 249.402 258.361 280.077 265.069 Z')
						.subtract(paperOffset.offset(main, 7 * (regardant ? -1 : 1), {join:'round'}))
						.unite(getLionPassantBackLeg())
					) as paper.Path;
					let passantClaws = (new paper.Path('M 58.143 171.241 C 70.453 173.491 79.317 181.984 79.307 196.234 C 79.303 201.879 57.687 203.928 62.582 196.204 C 68.282 187.211 63.139 177.169 58.143 171.241 Z')
						.unite(new paper.Path('M 6.676 204.609 C 14.439 195.369 27.768 195.353 38.784 204.84 C 43.149 208.599 34.595 225.206 28.593 217.397 C 21.451 208.105 13.706 204.195 6.676 204.609 Z'))
						.unite(new paper.Path('M -0.012 261.663 C -2.125 249.782 6.409 239.543 20.753 237.172 C 26.436 236.232 33.696 253.444 23.855 253.043 C 12.145 252.567 4.178 256.003 -0.012 261.663 Z'))
						.unite(new paper.Path('M 37.501 298.592 C 30.233 292.298 25.793 284.939 32.389 271.982 C 35.002 266.849 50.696 269.763 47.009 278.896 C 44.6 284.863 37.206 291.862 37.501 298.592 Z'))
						.unite(new paper.Path('M 100.814 507 C 102.272 494.571 110.18 485.182 124.401 484.28 C 130.035 483.922 133.463 505.363 125.442 500.972 C 116.103 495.859 106.41 501.635 100.814 507 Z'))
						.unite(new paper.Path('M 140.332 546.035 C 129.038 539.613 126 527.808 136.719 518.006 C 140.965 514.121 158.451 518.759 152.051 526.423 C 146.723 532.803 141.477 536.566 140.332 546.035 Z'))
						.unite(new paper.Path('M 184.065 550.754 C 172.245 548.641 160.999 539.86 165.917 527.285 C 167.863 522.303 179.796 519.86 181.793 528.845 C 183.579 536.883 181.252 541.687 184.065 550.754 Z'))
						.unite(new paper.Path('M 218.054 538.799 C 209.496 532.556 195.176 531.743 193.721 525.908 C 192.285 520.152 199.141 514.158 208.224 518.56 C 213.592 521.161 217.922 528.051 218.054 538.799 Z'))
						.unite(getLionPassantBackClaws())
					) as paper.Path;
					main = passantBody.unite(main) as paper.Path;
					armed = passantClaws.unite(armed) as paper.Path;
					break;
				}
			}
			paths.push(main);
			paths.push(langued);
			paths.push(armed);
			break;
		}
		case DeviceId.eagle: {
			let [main, armed, langued] = getEagleHead();
			if(part.attitudes[0] != Attitude.none) {
				let inflatedHead = paperOffset.offset(main, 8);
				// wings
				let wing = getWingForAttitude(part.attitudes[2]);
				let wing2 = wing.clone();
				if(part.attitudes[1] == Attitude.displayed) {
					wing2.scale(-1, 1, new paper.Point(316.3, 0));
				} else {
					wing2 = addorseWing(wing2);
				}
				// body
				let body: paper.Path;
				let claws: paper.Path;
				if(part.attitudes[0] == Attitude.displayed) {
					body = new paper.Path('M 257.199 465.006 C 247.015 461.531 254.037 451.316 243.394 454.979 C 231.466 459.085 216.058 457.839 216.197 440.66 C 231.067 463.411 238.716 430.57 259.079 407.279 C 223.059 353.974 204.337 267.312 265.631 232.744 L 380.514 252.48 C 411.865 276.366 402.731 356.557 373.809 407.585 C 393.974 430.856 401.62 463.312 416.425 440.661 C 416.564 457.839 401.156 459.085 389.229 454.979 C 378.585 451.316 385.607 461.531 375.423 465.006 C 372.771 442.401 362.772 460.891 336.107 448.649 C 341.174 458.414 343.974 470.874 342.743 483.723 C 340.114 511.148 366.13 521.467 381.594 499.654 C 382.731 537.641 352.075 531.257 346.451 523.96 C 348.986 545.601 387.025 529.876 375.022 581.561 C 360.899 542.472 344.996 568.034 334.26 541.638 C 330.306 561.062 348.126 608.824 406.709 579.06 C 406.709 579.06 374.822 635.544 329.272 591.9 C 324.481 622.788 363.729 629.876 316.311 677.152 C 268.893 629.876 308.141 622.788 303.35 591.9 C 257.8 635.544 225.913 579.06 225.913 579.06 C 284.496 608.824 302.316 561.062 298.362 541.638 C 287.626 568.034 271.723 542.472 257.6 581.561 C 245.597 529.876 283.636 545.601 286.171 523.96 C 280.547 531.257 249.891 537.641 251.028 499.654 C 266.492 521.467 292.508 511.148 289.879 483.723 C 288.648 470.874 291.448 458.413 296.515 448.648 C 269.85 460.891 259.851 442.4 257.199 465.006 Z')
					claws = (new paper.Path('M 506.436 478.983 C 506.619 479.006 506.817 479.04 507.03 479.084 C 511.037 477.747 520.812 477.029 528.684 483.671 C 525.03 483.293 521.682 483.404 518.068 484.722 C 520.189 486.719 521.014 488.927 518.618 490.814 C 516.205 492.713 509.147 490.528 501.6 492.942 C 495.867 494.774 489.666 498.279 483.845 502.117 C 499.858 503.782 509.784 497.118 517.392 504.525 C 517.596 504.723 517.806 504.949 518.018 505.199 C 523.117 506.058 532.542 510.475 532.622 524.973 C 530.205 518.908 525.915 516.076 521.641 514.928 C 521.313 516.497 520.155 517.603 517.68 517.656 C 514.611 517.723 507.078 515.409 499.597 512.795 C 493.311 510.599 486.575 509.869 479.807 509.624 C 487.787 518.795 503.56 514.554 507.287 536.166 C 507.414 536.903 507.242 537.625 506.853 538.282 C 507.633 541.669 507.367 550.5 503.355 557.43 C 503.847 553.021 503.077 546.099 500.258 541.213 C 498.254 541.018 496.318 539.933 495.208 537.505 C 489.735 525.532 475.704 513.739 465.127 511.902 C 448.416 509 426.668 521.204 419.785 522.195 C 417.91 522.464 416.536 522.023 415.572 521.154 C 407.18 525.109 407.369 533.231 407.369 533.231 C 407.369 533.231 402.741 515.776 414.448 511.407 C 414.716 510.687 415.044 510.049 415.416 509.544 C 422.059 500.518 431.324 509.975 447.897 504.813 C 436.754 496.495 412.981 472.509 398.484 470.347 C 392.759 469.493 386.771 463.201 382.217 457.13 C 383.049 454.707 384.038 453.193 389.229 454.979 C 394.879 456.924 401.311 457.668 406.501 456.086 C 426.042 473.227 450.627 493.938 459.408 497.669 C 463.027 499.207 468.992 499.003 473.928 498.443 C 492.785 490.265 494.517 477.468 506.436 478.983 Z')
						.unite(new paper.Path('M 158.694 498.443 C 163.63 499.003 169.595 499.207 173.214 497.669 C 181.995 493.938 206.58 473.227 226.121 456.086 C 231.311 457.668 237.743 456.924 243.394 454.979 C 248.584 453.193 249.573 454.707 250.406 457.13 C 245.851 463.201 239.863 469.493 234.138 470.347 C 219.641 472.509 195.868 496.495 184.725 504.813 C 201.298 509.975 210.563 500.518 217.206 509.544 C 217.578 510.049 217.906 510.687 218.174 511.407 C 229.881 515.776 225.253 533.231 225.253 533.231 C 225.253 533.231 225.442 525.109 217.05 521.154 C 216.086 522.023 214.712 522.464 212.837 522.195 C 205.954 521.204 184.206 509 167.495 511.902 C 156.918 513.739 142.887 525.532 137.414 537.505 C 136.304 539.933 134.368 541.018 132.364 541.213 C 129.545 546.099 128.775 553.021 129.267 557.43 C 125.255 550.5 124.989 541.669 125.769 538.282 C 125.38 537.625 125.208 536.903 125.335 536.166 C 129.062 514.554 144.835 518.795 152.815 509.624 C 146.047 509.869 139.311 510.599 133.025 512.795 C 125.544 515.409 118.011 517.723 114.942 517.656 C 112.467 517.603 111.309 516.497 110.981 514.928 C 106.707 516.076 102.417 518.908 100 524.973 C 100.08 510.475 109.505 506.058 114.604 505.199 C 114.816 504.949 115.026 504.723 115.23 504.525 C 122.838 497.118 132.764 503.782 148.777 502.117 C 142.956 498.279 136.755 494.774 131.022 492.942 C 123.475 490.528 116.417 492.713 114.004 490.814 C 111.608 488.927 112.433 486.719 114.554 484.722 C 110.94 483.404 107.592 483.293 103.938 483.671 C 111.81 477.029 121.585 477.747 125.592 479.084 C 125.805 479.04 126.003 479.006 126.186 478.983 C 138.105 477.468 139.837 490.265 158.694 498.443 Z'))
					) as paper.Path;
				} else {
					body = (new paper.Path('M 375.78 500.124 C 364.663 503.106 362.297 486.976 354.931 496.943 C 346.678 508.114 339.012 507.13 328.824 498.526 C 359.614 501.847 327.441 480.6 319.587 452.704 C 306.08 444.663 283.783 426.113 267.62 406.041 C 213.731 339.118 198.727 270.85 263.934 232.166 L 386.425 254.301 C 413.291 275.824 421.424 353.891 404.813 417.842 C 424.672 446.96 480.677 521.423 513.824 531.914 C 505.997 539.057 497.591 544.032 488.973 547.386 C 444.738 509.566 407.201 449.808 407.201 449.808 C 407.201 449.808 435.768 514.75 468.332 552.565 C 461.279 553.48 454.28 553.614 447.534 553.257 C 415.609 508.223 393.748 451.726 393.748 451.726 C 393.748 451.726 406.541 507.67 427.124 550.806 C 419.637 549.464 412.868 547.835 407.201 546.482 C 398.266 523.393 388.219 491.921 381.569 470.863 C 373.88 480.65 368.348 484.415 375.78 500.124 Z')
						.unite(new paper.Path('M 318.738 474.028 C 307.557 476.732 308.182 462.845 300.594 472.626 C 292.091 483.589 277.429 491.505 267.905 475.047 C 291.777 486.777 278.836 458.037 280.465 426.994 C 288.136 436.942 311.313 455.009 317.054 457.202 C 314.394 459.919 315.152 465.974 318.738 474.028 Z'))
					) as paper.Path;
					claws = (new paper.Path('M 371.579 513.288 C 371.726 525.501 386.93 570.216 393.26 588.116 C 402.008 600.201 419.042 587.114 426.923 596.563 C 427.365 597.093 427.769 597.774 428.119 598.552 C 440.955 602.312 437.63 622.261 437.63 622.261 C 437.63 622.261 437.09 613.168 427.814 609.553 C 426.869 610.616 425.45 611.24 423.434 611.12 C 416.032 610.671 391.816 599.12 374.328 603.964 C 363.258 607.031 348.576 613.111 343.854 627.016 C 342.896 629.835 340.938 631.234 338.827 631.643 C 336.277 637.373 336.09 645.183 337.014 650.062 C 332.121 642.703 331.034 632.859 331.554 629 C 331.08 628.303 330.832 627.512 330.901 626.678 C 332.889 602.168 354.019 607.43 358.525 602.825 C 351.357 603.749 343.642 603.205 337.164 606.26 C 329.455 609.898 322.071 612.49 318.806 612.709 C 316.169 612.887 314.84 611.762 314.349 610.041 C 309.913 611.733 305.614 615.309 303.599 622.317 C 302.362 606.109 311.972 600.271 317.31 598.821 C 317.513 598.522 317.714 598.248 317.914 598.008 C 325.321 589.001 336.692 598.22 353.552 594.824 C 347.019 591.093 340.74 589.241 333.479 590.231 C 325.1 591.374 317.494 594.493 314.758 592.603 C 312.041 590.725 312.716 588.178 314.786 585.743 C 310.828 584.617 305.206 586.413 301.358 587.185 C 308.788 577.91 321.621 577.275 325.999 578.384 C 326.221 578.315 326.429 578.257 326.621 578.215 C 339.145 575.379 342.973 582.436 363.751 589.768 C 369.045 589.921 377.114 589.09 378.091 587.118 C 379.711 572.099 358.062 517.61 351.283 501.13 C 352.494 499.992 353.706 498.602 354.931 496.943 C 361.655 487.844 364.212 500.493 373.063 500.499 C 372.72 504.791 371.534 509.619 371.579 513.288 Z')
						.unite(new paper.Path('M 306.024 484.398 C 298.85 493.517 304.143 537.043 307.602 553.705 C 316.35 565.79 334.179 544.324 342.059 553.772 C 342.502 554.303 342.906 554.984 343.257 555.762 C 356.092 559.521 352.766 579.471 352.766 579.471 C 352.766 579.471 352.227 570.377 342.952 566.762 C 342.006 567.826 340.587 568.449 338.57 568.329 C 331.169 567.881 305.945 565.44 288.457 570.284 C 277.388 573.352 262.706 579.432 257.984 593.336 C 257.025 596.155 255.067 597.554 252.956 597.963 C 250.407 603.694 250.219 611.503 251.144 616.382 C 246.251 609.023 245.164 599.179 245.684 595.32 C 245.21 594.623 244.962 593.833 245.031 592.998 C 247.018 568.488 268.149 573.75 272.654 569.146 C 265.487 570.069 257.771 569.525 251.294 572.58 C 243.585 576.218 236.201 578.81 232.935 579.029 C 230.299 579.207 228.969 578.082 228.478 576.361 C 224.042 578.053 219.743 581.629 217.728 588.638 C 216.491 572.43 226.101 566.591 231.44 565.142 C 231.643 564.842 231.844 564.569 232.044 564.329 C 239.45 555.321 250.822 564.54 267.681 561.144 C 261.148 557.413 254.869 555.561 247.608 556.551 C 239.23 557.694 231.624 560.813 228.888 558.924 C 226.171 557.045 226.846 554.498 228.916 552.063 C 224.958 550.937 219.336 552.734 215.488 553.505 C 222.918 544.23 235.75 543.595 240.129 544.704 C 240.351 544.635 240.559 544.578 240.75 544.535 C 253.275 541.7 257.103 548.757 277.88 556.088 C 283.175 556.241 292.658 555.429 293.634 553.457 C 296.153 540.715 292.517 505.75 289.365 482.378 C 293.562 480.226 297.489 476.629 300.594 472.626 C 305.735 465.999 307.107 470.237 310.933 472.819 C 309.772 477.487 308.123 481.731 306.024 484.398 Z'))
					) as paper.Path;
					wing2 = wing2.subtract(paperOffset.offset(body, 9)) as paper.Path;
				}
				main = body.unite(wing).unite(wing2).subtract(inflatedHead).unite(main) as paper.Path;
				armed = armed.unite(claws) as paper.Path;
			}
			paths.push(main);
			paths.push(langued);
			paths.push(armed);
			break;
		}
		case DeviceId.griffin: {
			let [main, armed, langued] = getEagleHead();
			main = main.unite(new paper.Path('M 328.118 100.398 C 343.685 82.183 413.652 74.626 419.665 78.763 C 419.665 78.763 373.188 130.831 346.282 116.021 C 350.191 114.879 388.934 98.206 391.218 92.154 C 376.212 89.612 348.116 99.155 337.747 105.858 L 328.118 100.398 Z')) as paper.Path;
			const regardant = part.attitudes[1] == Attitude.regardant;
			if(regardant) {
				const flipPoint = new paper.Point(315, 0);
				main.scale(-1, 1, flipPoint);
				armed.scale(-1, 1, flipPoint);
				langued.scale(-1, 1, flipPoint);
			}
			if(part.attitudes[0] != Attitude.none) {
				let inflatedHead = paperOffset.offset(main, 8 * (regardant ? -1 : 1));
				let wing = getWingForAttitude(part.attitudes[2]);
				let body: paper.Path;
				if(part.attitudes[0] == Attitude.rampant) {
					body = (new paper.Path('M 526.436 480.104 C 572.266 517.551 733.403 500.413 741.559 555.353 C 746.86 591.056 706.654 614.012 692.131 612.793 C 676.478 639.911 651.95 623.278 659.535 644.843 C 654.434 646.771 636.991 637.491 650.997 624.13 C 620.991 645.009 594.854 618.588 572.686 643.597 C 585.931 608.75 603.219 599.142 627.188 601.245 C 618.982 597.111 605.109 595.852 603.389 578.433 C 632.065 596.488 666.126 560.405 690.15 589.197 C 690.15 589.197 721 581.101 716.272 562.396 C 713.191 550.202 679.464 539.22 644.345 540.36 C 629.149 557.913 609.22 565.397 609.17 563.57 C 609.282 563.646 617.298 556.962 616.822 549.736 C 597.657 569.785 578.994 554.979 564.946 567 C 571.097 552.509 585.851 554.58 589.615 544.416 C 573.969 554.725 545.177 558.62 536.332 550.485 C 548.78 551.531 562.232 545.311 564.57 534.017 C 551.375 542.765 525.263 540.378 531.249 522.562 C 536.924 534.365 547.151 529.669 548.172 521.889 C 507.292 512.028 489.274 496.194 477.086 465.483 C 461.778 497.412 426.263 512.319 431.231 525 C 436.228 537.754 475 529.78 483.773 543.277 C 485.044 545.233 485.673 548.202 485.78 551.939 C 490.741 555.826 502.845 571.709 503.488 586.812 C 503.488 586.812 490.13 586.491 485.798 585.322 C 489.775 588.125 502.407 602.229 502.008 610.797 C 499.842 611.804 488.658 609.411 483.074 608.377 C 488.953 616.536 495.199 624.084 491.781 639.752 C 487.737 633.527 479.042 625.567 473.67 626.168 C 484.713 635.867 485.692 650.798 467.847 656.114 C 475.353 644.453 464.118 640.148 461.172 640.11 C 456.093 652.433 451.752 661.412 450 663.267 C 446.548 666.925 441.441 669.322 435.615 670.614 C 438.753 674.703 440.716 679.691 439.572 682.798 C 437.245 689.122 421.481 689.604 417.284 683.426 C 415.596 680.94 415.465 677.12 416.408 673.506 C 414.97 677.966 412.492 682.253 410.32 684.675 C 406.538 688.892 394.209 686.386 391.493 678.858 C 390.445 675.954 391.907 671.619 394.622 667.624 C 392.413 670.346 389.727 672.694 387.073 674.285 C 379.082 679.077 369.302 665.652 371.666 657.65 C 372.745 654 378.31 650.823 384.12 649.181 C 379.685 649.699 375.005 649.227 371.836 647.488 C 363.668 643.005 363.406 625.635 371.507 623.641 C 378.703 621.869 393.857 632.659 396.195 639.777 C 401.873 635.779 408.406 633.612 408.406 633.612 C 408.406 633.612 444.444 578.466 438.535 567.349 C 433.582 558.03 373.192 567.091 361.424 544.257 C 346.143 514.607 375 450.001 387.951 425 C 375 411.383 358.633 384.197 312.374 375 C 305.267 373.587 300.907 371.657 298.088 369.73 C 268.883 381.95 246.846 371.593 231.011 393.275 C 214.792 387.916 225.034 382.453 217.053 374.09 C 210.929 367.674 197.179 362.059 201.995 348.679 C 229.473 367.136 228.322 333.022 284.66 279.002 L 294.765 226.96 L 323 213.049 C 390.797 242.563 452.958 333.657 475.205 395.757 C 512.193 439.417 505.956 463.371 526.436 480.104 Z')
						.unite(new paper.Path('M 396.114 665.619 C 396.331 665.352 396.552 665.088 396.779 664.827 C 396.743 664.805 396.708 664.783 396.673 664.761 C 396.493 665.049 396.306 665.336 396.114 665.619 Z'))
						.unite(new paper.Path('M 194.799 294.734 C 185.481 280.418 196.892 282.55 195.884 271.034 C 195.11 262.198 187.88 249.224 200 241.784 C 208.796 269.767 225.825 251.47 283.68 242.076 L 277.285 275.013 C 263.321 288.668 252.945 300.917 244.814 311.324 C 226.198 301.565 215.203 289.192 194.799 294.734 Z'))
						.unite(getLionRampantBackLeg())
					) as paper.Path;
					armed = (armed.unite(getLionRampantBackClaws())
						.unite(new paper.Path('M 115.818 422.725 C 121.827 423.787 129.126 424.491 133.68 422.88 C 142.388 419.802 180.138 389.035 208.113 366.573 C 211.229 369.283 214.703 371.628 217.053 374.09 C 222.493 379.791 219.466 384.144 222.125 388.036 C 217.396 391.363 213.067 393.788 210.456 394.013 C 192.517 395.562 161.545 423.163 147.25 432.514 C 167.178 440.105 179.257 429.214 186.716 440.785 C 187.133 441.434 187.487 442.24 187.761 443.144 C 201.782 449.391 194.78 470.441 194.78 470.441 C 194.78 470.441 195.63 460.496 185.641 455.009 C 184.393 456.001 182.675 456.437 180.397 455.964 C 172.032 454.226 146.296 437.609 125.585 439.897 C 112.478 441.345 94.377 454.737 86.756 469.001 C 85.21 471.894 82.754 473.077 80.282 473.163 C 76.454 478.939 74.984 487.368 75.252 492.811 C 70.86 484.009 71.205 473.161 72.42 469.068 C 71.992 468.232 71.836 467.334 72.048 466.44 C 78.261 440.226 97.278 446.625 107.759 435.987 C 99.443 435.772 91.128 436.155 83.254 438.37 C 73.883 441.006 64.47 443.271 60.713 442.955 C 57.683 442.701 56.346 441.258 56.063 439.309 C 50.736 440.391 45.261 443.537 41.835 450.79 C 43.037 433.02 54.928 428.321 61.246 427.656 C 61.524 427.365 61.799 427.104 62.064 426.877 C 71.956 418.373 83.62 427.3 103.38 426.475 C 96.534 421.328 89.197 416.558 82.308 413.876 C 73.237 410.342 64.418 412.484 61.604 409.972 C 58.809 407.477 59.989 404.833 62.741 402.545 C 58.411 400.654 54.314 400.264 49.805 400.449 C 59.963 392.904 71.893 394.528 76.704 396.471 C 76.969 396.434 77.214 396.408 77.44 396.393 C 92.169 395.442 93.319 411.264 115.818 422.725 Z'))
						.unite(new paper.Path('M 112.966 193.608 C 114.273 199.569 116.402 206.587 119.625 210.184 C 125.342 216.565 162.601 236.979 193.046 253.72 C 192.915 259.643 195.444 266.008 195.884 271.034 C 196.427 277.236 193.367 279.48 191.884 282.466 C 184.276 278.233 177.248 273.462 175.554 270.182 C 167.291 254.185 129.974 236.057 115.884 226.401 C 116.454 247.718 131.125 254.738 123.265 266.041 C 122.825 266.674 122.214 267.309 121.482 267.906 C 121.046 283.25 98.916 284.792 98.916 284.792 C 98.916 284.792 108.435 281.791 109.704 270.464 C 108.312 269.689 107.254 268.266 106.824 265.98 C 105.246 257.584 110.81 227.457 100.808 209.179 C 94.477 197.61 75.202 185.974 59.111 184.358 C 55.847 184.031 53.818 182.211 52.797 179.957 C 45.998 178.618 37.644 180.468 32.713 182.788 C 39.18 175.375 49.342 171.563 53.588 171.128 C 54.198 170.415 54.97 169.927 55.877 169.783 C 82.482 165.546 83.807 185.567 97.636 191.207 C 94.666 183.436 91.146 175.893 86.099 169.455 C 80.094 161.794 74.415 153.953 73.277 150.359 C 72.356 147.461 73.182 145.675 74.877 144.671 C 71.847 140.158 66.854 136.294 58.843 135.888 C 75.731 130.231 84.604 139.437 87.625 145.026 C 88.001 145.173 88.346 145.327 88.657 145.486 C 100.287 151.394 96.475 165.578 104.762 183.536 C 106.916 175.245 108.531 166.645 108.388 159.254 C 108.201 149.52 102.862 142.182 104.113 138.624 C 105.356 135.089 108.251 135.173 111.414 136.846 C 111.514 132.122 110.314 128.185 108.426 124.087 C 119.271 130.605 122.312 142.255 122.347 147.444 C 122.483 147.674 122.6 147.891 122.701 148.094 C 129.188 161.351 114.996 168.44 112.966 193.608 Z'))
					) as paper.Path;
				} else {
					body = (new paper.Path('M 283.304 427.515 C 266.806 431.942 272.366 421.753 261.104 419.146 C 252.462 417.147 237.888 420.004 234.565 406.178 C 267.665 406.514 252.31 365.396 269.731 289.313 L 285.526 249.06 L 325.869 220.652 C 379.644 217.801 405.889 244.24 465.979 249.406 C 506.617 252.896 540.675 244.332 576.078 254.128 C 601.243 261.091 622.557 288.979 644.931 291.476 C 703.75 298.042 829.764 196.165 866.443 237.874 C 890.278 264.979 868.977 306.086 856.119 312.947 C 857.697 344.219 828.069 343.567 846.146 357.559 C 842.909 361.948 823.223 363.625 827.732 344.8 C 813.868 378.625 777.574 370.627 772.535 403.665 C 764.739 367.21 774.041 349.755 795.312 338.508 C 786.176 339.492 773.842 345.966 762.939 332.272 C 796.825 331.866 805.838 283.07 841.645 294.207 C 841.645 294.207 863.157 270.659 849.031 257.518 C 839.823 248.95 805.537 258.039 776.664 278.063 C 773.433 301.054 760.76 318.159 759.726 316.652 C 759.861 316.655 762.964 306.691 758.641 300.88 C 753.432 328.122 729.72 325.82 724.449 343.542 C 721.747 328.032 735.262 321.762 732.904 311.183 C 725.362 328.335 703.298 347.238 691.454 345.208 C 702.475 339.329 710.395 326.802 706.227 316.048 C 699.894 330.558 676.671 342.73 672.025 324.519 C 683.199 331.35 689.238 321.854 685.871 314.766 C 654.072 325.915 632.518 325.874 611.363 315.551 C 612.522 350.261 597.959 393.483 608.312 398.271 C 620.744 404.019 643.217 371.432 658.889 375.104 C 661.16 375.635 663.67 377.344 666.332 379.968 C 672.603 379.342 692.332 382.431 703.248 392.888 C 703.248 392.888 693.383 401.9 689.446 404.054 C 694.257 403.326 713.136 404.766 718.777 411.227 C 717.91 413.452 708.181 419.466 703.434 422.582 C 713.325 424.404 723.057 425.53 731.432 439.206 C 724.205 437.511 712.42 437.782 708.957 441.933 C 723.642 441.293 734.68 451.394 725.477 467.58 C 722.826 453.968 711.736 458.635 709.583 460.646 C 714.445 473.057 716.904 482.624 717.543 485.094 C 720.335 495.872 715.764 498.844 712.453 503.809 C 717.547 504.589 722.416 506.832 723.74 509.866 C 726.438 516.041 715.391 527.298 708.086 525.743 C 705.147 525.116 702.409 522.449 700.588 519.189 C 702.637 523.402 703.815 528.212 703.923 531.463 C 704.111 537.125 693.477 543.848 686.306 540.293 C 683.54 538.922 681.595 534.781 680.791 530.018 C 681.081 533.511 680.766 537.064 679.951 540.051 C 677.499 549.039 661.148 546.116 657.317 538.704 C 655.57 535.322 657.389 529.178 660.447 523.972 C 657.604 527.415 653.899 530.313 650.408 531.25 C 641.409 533.666 629.2 521.309 633.668 514.263 C 637.636 508.004 656.043 505.307 662.656 508.827 C 663.988 502.012 666.996 492.47 666.996 492.47 C 666.996 492.47 654.849 427.723 642.89 423.787 C 632.865 420.487 595.542 468.819 571.245 460.479 C 539.696 449.649 504.951 370.214 496.999 343.204 C 431.671 330.093 395.141 364.279 332.4 371.19 C 314.848 395.515 284.595 401.446 283.304 427.515 Z')
						.unite(new paper.Path('M 198.929 365.045 C 183.281 358.198 193.988 353.714 186.822 344.643 C 181.323 337.683 168.156 330.811 174.2 317.937 C 189.856 330.726 220.109 294.325 240.726 275.471 C 250.024 266.967 257.273 267.977 262.341 267.975 C 258.293 276.245 258.934 287.138 260.918 291.681 C 256.747 310.761 252.081 338.532 251.001 351.694 C 230.084 353.76 212.939 349.21 198.929 365.045 Z'))
						.unite(getLionPassantBackLeg())
					) as paper.Path;
					armed = (armed.unite(getLionPassantBackClaws())
						.unite(new paper.Path('M 264.853 432.599 C 256.399 437.677 238.436 477.79 235.146 497.171 C 245.277 511.167 264.865 487.136 273.991 498.079 C 274.505 498.694 274.972 499.482 275.379 500.383 C 290.244 504.737 286.392 527.842 286.392 527.842 C 286.392 527.842 285.768 517.31 275.026 513.123 C 273.93 514.355 272.287 515.077 269.951 514.938 C 261.379 514.419 232.166 511.592 211.912 517.202 C 199.092 520.755 182.088 527.797 176.619 543.9 C 175.508 547.165 173.241 548.785 170.796 549.259 C 167.844 555.896 167.626 564.94 168.697 570.591 C 163.03 562.068 161.772 550.667 162.374 546.198 C 161.825 545.391 161.538 544.476 161.618 543.509 C 163.919 515.122 188.392 521.216 193.609 515.884 C 185.309 516.953 176.372 516.323 168.871 519.861 C 159.943 524.075 151.391 527.077 147.608 527.33 C 144.556 527.536 143.015 526.233 142.446 524.24 C 137.309 526.2 132.33 530.341 129.996 538.459 C 128.564 519.688 139.694 512.925 145.877 511.247 C 146.112 510.899 146.345 510.583 146.576 510.305 C 155.154 499.873 168.324 510.55 187.85 506.617 C 180.284 502.295 173.011 500.151 164.602 501.297 C 154.899 502.621 146.09 506.233 142.921 504.045 C 139.775 501.869 140.556 498.919 142.954 496.099 C 138.37 494.795 131.859 496.876 127.402 497.769 C 136.007 487.027 150.869 486.292 155.94 487.576 C 156.197 487.496 156.438 487.43 156.659 487.381 C 171.165 484.097 175.599 492.27 199.662 500.761 C 205.794 500.938 213.593 499.757 214.724 497.473 C 223.767 486.008 240.175 447.411 251.276 417.985 C 254.786 418.357 258.265 418.489 261.104 419.146 C 267.146 420.545 268.346 424.126 270.708 426.461 C 269.024 429.078 266.97 431.327 264.853 432.599 Z'))
						.unite(new paper.Path('M 75.008 325.467 C 79.374 329.731 85.007 334.427 89.676 335.664 C 97.958 337.857 140.306 334.458 174.943 331.731 C 178.086 336.753 183.695 340.684 186.823 344.643 C 190.682 349.528 189.357 353.084 189.757 356.394 C 181.075 357.034 172.581 356.906 169.364 355.095 C 153.674 346.263 112.532 351.604 95.455 351.271 C 107.637 368.774 123.753 366.584 123.39 380.347 C 123.37 381.118 123.208 381.984 122.924 382.885 C 130.986 395.948 113.337 409.388 113.337 409.388 C 113.337 409.388 119.645 401.653 114.486 391.49 C 112.897 391.607 111.231 390.998 109.616 389.324 C 103.687 383.174 91.794 354.94 73.398 345.157 C 61.754 338.964 39.255 339.824 24.92 347.31 C 22.013 348.829 19.318 348.422 17.227 347.099 C 10.809 349.713 4.843 355.847 1.996 360.493 C 3.33 350.747 9.73 341.981 13.039 339.286 C 13.158 338.355 13.535 337.523 14.214 336.904 C 34.122 318.754 46.224 334.759 60.878 331.879 C 54.129 327.015 47.045 322.644 39.292 320.035 C 30.066 316.93 21.014 313.495 18.09 311.116 C 15.729 309.2 15.438 307.254 16.303 305.484 C 11.293 303.376 4.998 302.889 -1.92 306.948 C 9.088 292.947 21.558 295.768 27.152 298.78 C 27.547 298.697 27.92 298.636 28.267 298.598 C 41.231 297.149 45.834 311.097 62.621 321.555 C 59.869 313.443 56.496 305.368 52.318 299.27 C 46.816 291.238 38.325 288.037 37.417 284.376 C 36.514 280.739 38.98 279.22 42.542 278.881 C 40.031 274.878 36.867 272.247 33.038 269.859 C 45.681 269.351 54.62 277.417 57.499 281.735 C 57.739 281.852 57.956 281.969 58.151 282.083 C 70.853 289.601 62.885 303.318 75.008 325.467 Z'))
					) as paper.Path;
					wing.rotate(-45, new paper.Point(390, 210));
				}
				main = main.unite(body.unite(wing).subtract(inflatedHead)) as paper.Path;
				main = main.unite(addorseWing(wing).subtract(paperOffset.offset(main, 8))) as paper.Path;
			}
			paths.push(main);
			paths.push(langued);
			paths.push(armed);
			break;
		}
		default: {
			let path = new paper.Path.Circle(box.center, box.width/2);
			if(dev.id == DeviceId.annulet) {
				path = path.subtract(new paper.Path.Circle(box.center, box.width*.3)) as paper.Path;
			}
			paths.push(path);
			break;
		}
	}
	let minX: number = Infinity;
	let maxX: number = -Infinity;
	let minY: number = Infinity;
	let maxY: number = -Infinity;
	for(let path of paths) {
		let bounds = path.bounds;
		minX = Math.min(bounds.left, minX);
		maxX = Math.max(bounds.right, maxX);
		minY = Math.min(bounds.top, minY);
		maxY = Math.max(bounds.bottom, maxY);
	}
	let rect = new paper.Path.Rectangle(new paper.Rectangle({ from: [minX, minY], to: [maxX, maxY] }));
	let group = new paper.Group([...paths, rect]);
	group.fitBounds(box);
	paths = group.removeChildren() as paper.Path[];
	paths.pop();
	return paths;
}

function getFessPointForDevice(device: Device, path: paper.Path): paper.Point {
	let box: any = path.bounds;
	let ratio;
	switch(device.id) {
		case DeviceId.heater:
			ratio = new paper.Point(.5, .44);
			break;
		default:
			let coords = ['x','y'].map(coord => {
				let measure = coord == 'x' ? 'width' : 'height';
				let upperBound = box[coord] + box[measure];
				let lowerBound = box[coord];
				let workingCoord = lowerBound;
				for(let i=0; i<20; i++) {
					workingCoord = upperBound + (lowerBound - upperBound) * .5;
					let divisions = dividePath(path,
						new Division(coord == 'x' ? DivisionType.pale : DivisionType.fess, DivisionLine.straight),
						new paper.Point(workingCoord, workingCoord),
					);
					let areas = divisions.map(div => (div as paper.Path).area);
					let difference = areas[0] - areas[1];
					if(Math.abs(difference) < box[measure]*.05) {
						break;
					}
					if(difference < 0) {
						lowerBound = workingCoord;
					} else {
						upperBound = workingCoord;
					}
				}
				return workingCoord;
			});
			return new paper.Point(coords[0], coords[1]);
	}
	return new paper.Point(box.x + ratio.x * box.width, box.y + ratio.y * box.height);
}

function getIntersectionPathForDivision(path: paper.Path, fessPoint: paper.Point, division: Division): paper.Path {
	let box = path.bounds;
	let lineSegments = [];
	let inProgressPath: paper.Path|null = null;
	if(division.line != DivisionLine.straight) {
		let approxFinalLength = Math.min(box.width, box.height);
		let paramMap = new Map<DivisionLine, {reps:number, orth:number}>([
			[DivisionLine.indented, {reps:12, orth:.5}],
			[DivisionLine.wavy, {reps:6, orth:.15}],
			[DivisionLine.embattled, {reps:10, orth:.3}],
			[DivisionLine.engrailed, {reps:7, orth:1.1}],
			[DivisionLine.invected, {reps:7, orth:1.1}],
		]);
		let params = paramMap.get(division.line)!;
		let inc = approxFinalLength / params.reps;
		let steps = Math.ceil(200 / inc);
		let workingY = fessPoint.y - inc * steps;
		for(let i=0; i<steps*2; i++) {
			workingY += inc;
			if(division.line == DivisionLine.embattled) {
				let dirs = [-1, 1];
				if(i%2 == 0) {
					dirs.reverse();
				}
				lineSegments.push(...dirs.map(dir => new paper.Segment(
					new paper.Point(fessPoint.x + dir * inc * params.orth, workingY + .5*inc)
				)));
			} else if([DivisionLine.indented, DivisionLine.wavy].includes(division.line)) {
				let x = fessPoint.x + (i%2 == 0 ? -1 : 1) * inc * params.orth;
				lineSegments.push(new paper.Segment(
					new paper.Point(x, workingY),
					...(division.line == DivisionLine.wavy ? [new paper.Point(0, -inc*.5), new paper.Point(0, inc*.5)] : []),
				));
			} else if([DivisionLine.engrailed, DivisionLine.invected].includes(division.line)) {
				let circ = new paper.Path.Circle(new paper.Point(fessPoint.x, workingY), inc * params.orth * .5)
				if(!inProgressPath) {
					inProgressPath = circ;
				} else {
					inProgressPath = circ.unite(inProgressPath) as paper.Path;
				}
			}
		}
	}
	if(!lineSegments.length) {
		lineSegments.push(
			new paper.Segment(new paper.Point(fessPoint.x, fessPoint.y + 200)),
			new paper.Segment(new paper.Point(fessPoint.x, fessPoint.y - 200)),
		);
	}
	lineSegments.push(
		new paper.Segment(new paper.Point(fessPoint.x - 200, fessPoint.y - 200)),
		new paper.Segment(new paper.Point(fessPoint.x - 200, fessPoint.y + 200)),
	);
	let divisionPath = new paper.Path(lineSegments);
	let engrailOffset = (inProgressPath?.bounds.width ?? 0)/3;
	if(DivisionLine.engrailed == division.line) {
		divisionPath = divisionPath.unite(inProgressPath!) as paper.Path;
		engrailOffset *= -1;
	} else if(DivisionLine.invected == division.line) {
		divisionPath = divisionPath.subtract(inProgressPath!) as paper.Path;
	} else {
		engrailOffset = 0;
	}
	switch(division.type) {
		case DivisionType.pale:
			divisionPath.scale(1, -1);
			break;
		case DivisionType.fess:
			divisionPath.rotate(90, fessPoint);
			break;
		case DivisionType.bend:
			divisionPath.rotate(135, fessPoint);
			break;
		case DivisionType.bendSinister:
			divisionPath.rotate(45, fessPoint);
			break;
		default:
			throw new Error(`No intersection path for division ${division}`);
	}
	if(engrailOffset) {
		divisionPath.translate(new paper.Point(0, engrailOffset * Math.SQRT1_2));
	}
	return divisionPath;
}

function getRightAnglePathForLine(path: paper.Path, fessPoint: paper.Point, line: DivisionLine, exterior:boolean): paper.Path {
	let divLine = line;
	let mirrors = [DivisionLine.engrailed, DivisionLine.invected];
	if(mirrors.includes(divLine)) {
		if(!exterior) {
			let idx = mirrors.indexOf(divLine);
			if(idx > -1) {
				mirrors.reverse();
				divLine = mirrors[idx];
			}
		}
		if(divLine == DivisionLine.invected) {
			let base = new paper.Path.Rectangle(new paper.Rectangle(new paper.Point(fessPoint.x,-200), new paper.Size(200,400)));
			let engrailed = getRightAnglePathForLine(path, fessPoint, DivisionLine.engrailed, true);
			base = base.subtract(engrailed) as paper.Path;
			let intersectionPoint = new paper.Point(fessPoint.x, engrailed.bounds.bottom);
			engrailed.scale(1, -1, intersectionPoint);
			base = base.subtract(engrailed) as paper.Path;
			base.rotate(-90, intersectionPoint);
			return base;
		}
	}
	let divisionPaths = [DivisionType.bend, DivisionType.bendSinister];
	let divisions = divisionPaths.map(d => getIntersectionPathForDivision(path, fessPoint, new Division(d, divLine)));
	let intersection = divisions[0].intersect(divisions[1]) as paper.Path;
	return intersection;
}

function dividePath(path: paper.Path, division: Division, fessPoint: paper.Point, line: boolean=false): paper.Path[] {
	if([DivisionType.saltire, DivisionType.quarterly].includes(division.type)) {
		let paleIntersection = getIntersectionPathForDivision(
			path, fessPoint, new Division(DivisionType.pale, DivisionLine.straight)
		);
		if(division.type == DivisionType.quarterly && line) {
			let fessLine = getIntersectionPathForDivision(path, fessPoint,
				new Division(DivisionType.fess, DivisionLine.straight)
			);
			return [
				fessLine.intersect(path.intersect(paleIntersection), {trace:false}),
				fessLine.intersect(path.subtract(paleIntersection), {trace:false}),
				paleIntersection.intersect(path, {trace:false}),
			] as paper.Path[];
		}
		let topRightAngleLine = getRightAnglePathForLine(path, fessPoint, division.line, true);
		let yDif = topRightAngleLine.bounds.bottom - fessPoint.y;
		topRightAngleLine.translate(new paper.Point(0, -yDif));
		let bottomRightAngleLine = topRightAngleLine.clone();
		bottomRightAngleLine.scale(1,-1,fessPoint);
		if(!line) {
			if(division.type == DivisionType.quarterly) {
				topRightAngleLine.rotate(-45, fessPoint);
				bottomRightAngleLine.rotate(-45, fessPoint);
				paleIntersection.rotate(-45, fessPoint);
			}
			let result = [
				path.intersect(topRightAngleLine),
				path.subtract(topRightAngleLine).subtract(bottomRightAngleLine).intersect(paleIntersection),
				path.subtract(topRightAngleLine).subtract(bottomRightAngleLine).subtract(paleIntersection),
				path.intersect(bottomRightAngleLine),
			] as paper.Path[];
			if(division.type == DivisionType.quarterly) {
				let toSwap = result[1];
				result[1] = result[2];
				result[2] = toSwap;
			}
			return result;
		} else {
			return [
				topRightAngleLine.intersect(path.intersect(paleIntersection), {trace:false}),
				topRightAngleLine.intersect(path.subtract(paleIntersection), {trace:false}),
				bottomRightAngleLine.intersect(path.intersect(paleIntersection), {trace:false}),
				bottomRightAngleLine.intersect(path.subtract(paleIntersection), {trace:false}),
			] as paper.Path[];
		}
	} else if([DivisionType.chevron, DivisionType.chevronReversed].includes(division.type)) {
		let reversed = DivisionType.chevronReversed == division.type;
		let anglePoint = fessPoint.clone();
		anglePoint.y += path.bounds.height * .18 * (reversed ? 1 : -1);
		let rightAngleLine = getRightAnglePathForLine(path, anglePoint, division.line, reversed);
		if(!reversed) {
			rightAngleLine.scale(1,-1,anglePoint);
		}
		if(!line) {
			return [path.intersect(rightAngleLine), path.subtract(rightAngleLine)] as paper.Path[];
		} else {
			rightAngleLine.scale(-1,1,anglePoint);
			let paleIntersection = getIntersectionPathForDivision(
				path, fessPoint, new Division(DivisionType.pale, DivisionLine.straight)
			);
			return [
				rightAngleLine.intersect(path.intersect(paleIntersection), {trace:false}),
				rightAngleLine.intersect(path.subtract(paleIntersection), {trace:false}),
			] as paper.Path[];
		}
	} else {
		const intersectionPath = getIntersectionPathForDivision(path, fessPoint, division);
		if(!line) {
			intersectionPath.closePath();
			return [path.intersect(intersectionPath), path.subtract(intersectionPath)] as paper.Path[];
		} else {
			return [intersectionPath.intersect(path, {trace:false})] as paper.Path[];
		}
	}
}

function calcShieldPart(
	part: Part, path: paper.Path, targetParts: Part[]|null=null, parentFessPoint: paper.Point|null=null
): PathData[] {
	let paths: PathData[] = [];
	let fessPoint = getFessPointForDevice(part.device, path);
	// divisions / field
	let applyTincture = (tincturedPath: paper.Path, tincture: Tincture): PathData[] => {
		let result = [];
		if(![Tincture.ermine, Tincture.vair].includes(tincture)) {
			result.push({ path:tincturedPath?.pathData, color:colorMap.get(tincture) });
		} else {
			result.push({ path:tincturedPath?.pathData, color:colorMap.get(Tincture.argent) });
			let even = true;
			for(let y=-49.99; y<60; y+=10) {
				let xOffset = even ? 0 : 5;
				for(let baseX=-50; baseX<60; baseX+=10) {
					let x = baseX + xOffset;
					if(tincture == Tincture.ermine) {
						let tipY = y + 6;
						let halfWidth = 2.5;
						let nudge = halfWidth*.8;
						let dotRad = .7;
						let dotOffset = 1.3;
						let spotPaths = [
							new paper.Path([
								new paper.Segment(new paper.Point(x+halfWidth*.3, tipY-1)),
								new paper.Segment(new paper.Point(x, tipY)),
								new paper.Segment(new paper.Point(x-halfWidth*.3, tipY-1)),
								new paper.Segment(
									new paper.Point(x-halfWidth, tipY), undefined, new paper.Point(nudge, -halfWidth),
								),
								new paper.Segment(new paper.Point(x, y)),
								new paper.Segment(
									new paper.Point(x+halfWidth, tipY), new paper.Point(-nudge, -halfWidth),
								),
							]),
							new paper.Path.Circle(new paper.Point(x, y-dotOffset), dotRad),
							new paper.Path.Circle(new paper.Point(x-dotOffset, y), dotRad),
							new paper.Path.Circle(new paper.Point(x+dotOffset, y), dotRad),
						].map(p => p.intersect(tincturedPath)).filter(p => (p as paper.Path).area);
						result.push(...spotPaths.map(s => ({path:s.pathData, color:colorMap.get(Tincture.sable)})));
					} else {
						let spotPath = new paper.Path([
							new paper.Point(x,y),
							new paper.Point(x+2.5, y+3),
							new paper.Point(x+2.5, y+7),
							new paper.Point(x+5, y+10),
							new paper.Point(x-5, y+10),
							new paper.Point(x-2.5, y+7),
							new paper.Point(x-2.5, y+3),
						]).intersect(tincturedPath) as paper.Path;
						if(spotPath.area) {
							result.push({
								path: spotPath.pathData,
								color: colorMap.get(Tincture.azure),
							});
						}
					}
				}
				even = !even;
			}
		}
		return result;
	};
	if(part.division.type != DivisionType.none) {
		let subdivisions = dividePath(path, part.division, fessPoint);
		if(targetParts?.includes(part)) {
			paths.push({ path:path?.pathData, color:'wheat' });
			return paths;
		}
		paths.push(...part.parts.flatMap((p, i) => calcShieldPart(p, subdivisions[i], targetParts, fessPoint)));
	} else {
		if(!targetParts || targetParts?.includes(part)) {
			paths.push(...applyTincture(path, part.field.tincture));
			if(part.field.variation != FieldVariation.plain) {
				let corner = path.bounds.topLeft;
				let rotation = 0;
				if(part.field.variation == FieldVariation.paly) {
					rotation = 90;
				}
				if(part.field.variation == FieldVariation.chequy) {
					rotation = -90;
				}
				if(part.field.variation == FieldVariation.bendySinister) {
					rotation = 45;
				}
				if([FieldVariation.bendy, FieldVariation.lozengy].includes(part.field.variation)) {
					rotation = -45;
				}
				if(rotation) {
					path.rotate(rotation, corner);
				}
				let bars: paper.Path[] = [];
				let barSize = path.bounds.height / part.field.number;
				let orthogonalBars: paper.Path[] = [];
				let twoWay = [FieldVariation.lozengy, FieldVariation.chequy].includes(part.field.variation);
				if(twoWay) {
					let orth = path.clone();
					for(
						let div = new paper.Path.Rectangle(
							new paper.Rectangle(new paper.Point(path.bounds.x+barSize, -200), new paper.Size(200,400))
						);
						div.bounds.x-barSize < path.bounds.right;
						div.translate(new paper.Point(barSize, 0))
					) {
						orthogonalBars.push(orth.subtract(div) as paper.Path);
						orth = orth.intersect(div) as paper.Path;
					}
				}
				let line = twoWay ? DivisionLine.straight : part.field.variationLine;
				let divider = getIntersectionPathForDivision(path,
					new paper.Point(fessPoint.x, path.bounds.y),
					new Division(DivisionType.fess, line),
				);
				for(let i=0; i<part.field.number; i++) {
					let bar = path.subtract(divider);
					divider.translate(new paper.Point(0, barSize));
					bar = bar.intersect(divider);
					let oddRow = i%2 == 1;
					if(twoWay) {
						for(let [j,orth] of orthogonalBars.entries()) {
							let oddCol = j%2 == 1;
							if(oddRow == oddCol) {
								bars.push(bar.intersect(orth) as paper.Path);
							}
						}
					} else if(oddRow) {
						bars.push(bar as paper.Path);
					}
				}
				if(rotation) {
					path.rotate(-rotation, corner);
					bars.forEach(b => b.rotate(-rotation, corner));
				}
				bars.forEach(b => paths.push(...applyTincture(b, part.field.tinctureSecondary)));
			}
		}
		if(targetParts?.includes(part)) {
			return paths;
		}
	}
	// mobile charges
	let chargePathMap = new Map<Part, PathData[]>();
	let mobileCharges = part.charges.filter(c => [DeviceType.mobileCharge, DeviceType.beast].includes(c.device.type));
	if(mobileCharges.length) {
		let minChargeSeparation: number = Infinity;
		let lines: paper.Path[] = [];
		let chargesPerLine: number[] = [mobileCharges.length];
		let getLinesByCount = (count:number): [paper.Path[], number] => {
			let spaceAbove = fessPoint.y - path.bounds.top;
			let lineHeight = spaceAbove/.75;
			if(count > 1) {
				lineHeight = path.bounds.height / (count + .5);
			}
			let result = [];
			for(let i=0; i<count; i++) {
				let dividingLine = dividePath(path,
					new Division(DivisionType.fess, DivisionLine.straight),
					new paper.Point(fessPoint.x, path.bounds.y + (i+.75)*lineHeight),
					true,
				).pop();
				if(dividingLine) {
					result.push(dividingLine);
				}
			}
			return [result, lineHeight];
		};
		let distributeCharges = (chargeCount:number, lineSet: paper.Path[], existingPositions:number=0): number[] => {
			// get first approximation of how many charges go on each line, rounding down
			let totalLength = lineSet.reduce((acc,curr) => acc+curr.length, 0);
			let totalSections = chargeCount + lineSet.length - existingPositions;
			let chargesPerLineInfo = lineSet.map(l => {
				let expected = Math.max(1, (l.length / totalLength) * totalSections);
				return {line:l, expected:expected, actual:Math.floor(expected)};
			});
			// distribute any remaining charges to the rows with most spare space
			let distributedCharges = chargesPerLineInfo.reduce((acc,curr) => curr.actual + acc, 0);
			let toDistribute = totalSections - distributedCharges;
			if( // for symmetric cross arrangements, try to remain symmetric
				targetArrangement == ChargeArrangement.crosswise &&
				chargesPerLineInfo[0].actual == chargesPerLineInfo[1].actual
			) {
				if(toDistribute % 2 == 0) {
					let perArm = toDistribute/2;
					chargesPerLineInfo[0].actual += perArm;
					chargesPerLineInfo[1].actual += perArm;
				} else {
					chargesPerLineInfo[2].actual += toDistribute;
				}
			} else {
				chargesPerLineInfo.sort((a,b) => b.expected%1 - a.expected%1);
				for(let i=0; i<toDistribute; i++) {
					let info = chargesPerLineInfo[i];
					info.actual++;
				}
			}
			return lineSet.map(l => chargesPerLineInfo.find(i => i.line == l)!.actual - 1);
		};
		let ordinaryArrangementMap = new Map([
			[DeviceId.fess, ChargeArrangement.fesswise],
			[DeviceId.pale, ChargeArrangement.palewise],
			[DeviceId.bend, ChargeArrangement.bendwise],
			[DeviceId.bendSinister, ChargeArrangement.bendwiseSinister],
			[DeviceId.chevron, ChargeArrangement.chevronwise],
			[DeviceId.chevronReversed, ChargeArrangement.chevronwiseReversed],
			[DeviceId.saltire, ChargeArrangement.saltirewise],
			[DeviceId.cross, ChargeArrangement.crosswise],
		]);
		let targetArrangement = part.chargeArrangement;
		let targetMidPoint = fessPoint;
		if(targetArrangement == ChargeArrangement.unspecified) {
			let mapped = ordinaryArrangementMap.get(part.device.id);
			if(mapped) {
				targetArrangement = mapped;
				if(parentFessPoint) {
					targetMidPoint = parentFessPoint;
				}
			}
		}
		switch(targetArrangement) {
			case ChargeArrangement.specified: {
				chargesPerLine = [];
				let [createdLines, lineHeight] = getLinesByCount(part.chargeCountByRow.length);
				minChargeSeparation = lineHeight;
				for(let [i, line] of createdLines.entries()) {
					lines.push(line);
					chargesPerLine.push(part.chargeCountByRow[i]);
				}
				break;
			}
			case ChargeArrangement.unspecified: {
				let rowCount = Math.round(Math.sqrt(mobileCharges.length));
				let bestFactorDeviation = Infinity;
				// narrow in on number of rows that keeps horizontal and vertical charge separation as close as possible
				for(let t=0; t<20; t++) {
					let [createdLines, lineHeight] = getLinesByCount(rowCount);
					let fullLength = createdLines.reduce((acc,curr) => acc+curr.length, 0);
					let chargeSeparation = fullLength / mobileCharges.length;
					let params = [lineHeight, chargeSeparation].sort((a,b) => a-b);
					let factor = params[1] / params[0];
					let factorDeviation = Math.abs(factor-1);
					if(factorDeviation > bestFactorDeviation || factor == Infinity) {
						break;
					}
					bestFactorDeviation = factorDeviation;
					lines = createdLines.flatMap(l => l.children as paper.Path[] ?? [l]);
					minChargeSeparation = params[0];
					if(factor >= 2) {
						if(lineHeight < chargeSeparation) {
							factor = 1/factor;
						}
						rowCount = Math.round(rowCount * factor);
					} else {
						if(lineHeight < chargeSeparation) {
							rowCount--;
						} else {
							rowCount++;
							if(rowCount > mobileCharges.length) {
								break;
							}
						}
					}
				}
				break;
			}
			case ChargeArrangement.fesswise:
				lines = dividePath(path, new Division(DivisionType.fess, DivisionLine.straight), targetMidPoint, true);
				break;
			case ChargeArrangement.palewise:
				lines = dividePath(path, new Division(DivisionType.pale, DivisionLine.straight), targetMidPoint, true);
				break;
			case ChargeArrangement.bendwise:
				lines = dividePath(path, new Division(DivisionType.bend, DivisionLine.straight), targetMidPoint, true);
				break;
			case ChargeArrangement.bendwiseSinister:
				lines = dividePath(path, new Division(DivisionType.bendSinister, DivisionLine.straight), targetMidPoint, true);
				break;
			case ChargeArrangement.chevronwise:
				lines = dividePath(path, new Division(DivisionType.chevron, DivisionLine.straight), targetMidPoint, true);
				break;
			case ChargeArrangement.chevronwiseReversed:
				lines = dividePath(path, new Division(DivisionType.chevronReversed, DivisionLine.straight), targetMidPoint, true);
				break;
			case ChargeArrangement.crosswise:
				lines = dividePath(path, new Division(DivisionType.quarterly, DivisionLine.straight), targetMidPoint, true);
				break;
			case ChargeArrangement.saltirewise:
				lines = dividePath(path, new Division(DivisionType.saltire, DivisionLine.straight), targetMidPoint, true);
				break;
		}
		for(let i in lines) {
			let line = lines[i];
			if(line.children) {
				let children = line.children as paper.Path[];
				lines.splice(Number(i), 1, ...children);
				chargesPerLine.splice(Number(i), 1, ...distributeCharges(chargesPerLine[i], children));
			}
		}
		if(lines.length) {
			let chargePositions: paper.Point[] = [];
			// find charge separation if not already set
			if(minChargeSeparation == Infinity) {
				minChargeSeparation = Math.min(
					minChargeSeparation,
					lines.reduce((acc,curr) => acc+curr.length, 0) / mobileCharges.length
				);
			}
			let centerPosition = null;
			let pointEq = (a: paper.Point, b: paper.Point) => {
				let dist = ['x','y'].map(c => Math.abs((a as any)[c] - (b as any)[c]) < .0001);
				return dist[0] && dist[1]
			};
			if(chargesPerLine.length < lines.length) {
				// check for a center point
				if(mobileCharges.length % 2 == 1 &&
					(mobileCharges.length == 1 || targetArrangement != ChargeArrangement.crosswise)
				) {
					let endpoints = lines.flatMap(l => [l.segments[0], l.segments[l.segments.length-1]].map(s => s.point));
					let endpointCounts: {ep:paper.Point, count:number}[] = [];
					for(let endpoint of endpoints) {
						let count = endpointCounts.find(ct => pointEq(ct.ep, endpoint));
						if(!count) {
							count = {ep:endpoint, count:0};
							endpointCounts.push(count);
						}
						count.count++;
					}
					let greatestCount = endpointCounts.sort((a,b) => a.count - b.count).pop()!;
					if(greatestCount.count > 1) {
						centerPosition = greatestCount.ep;
					}
				}
				chargesPerLine = distributeCharges(mobileCharges.length, lines, centerPosition ? 1 : 0);
			}
			// calculate positions
			for(let [lineIdx, line] of lines.entries()) {
				let chargeCount = chargesPerLine[lineIdx];
				let chargeSeparation = line.length / chargeCount;
				if(chargeCount && chargeSeparation < minChargeSeparation) {
					minChargeSeparation = chargeSeparation;
				}
				for(let i=0; i<chargeCount; i++) {
					chargePositions.push(line.getPointAt(chargeSeparation * (i+.5)));
				}
				if(centerPosition && pointEq(centerPosition, line.segments[line.segments.length-1].point)) {
					chargePositions.push(centerPosition);
					centerPosition = null;
				}
			}
			let chargeSize = minChargeSeparation * .9;
			// ensure charges are (probably) not too big for available space
			for(let pos of chargePositions) {
				let lengths = [DivisionType.fess, DivisionType.pale, DivisionType.bend, DivisionType.bendSinister].map(
					div => dividePath(path, new Division(div, DivisionLine.straight), pos, true).pop()
				).map(l => (l?.length ?? 0) * .6).filter(n => n > 1);
				chargeSize = Math.min(chargeSize, ...lengths);
			}
			// create charge paths
			for(let [chargeIdx, charge] of mobileCharges.entries()) {
				let pos = chargePositions[chargeIdx];
				let chargePaths = getPathForPart(charge,
					new paper.Rectangle(
						new paper.Point(pos.x - chargeSize/2, pos.y - chargeSize/2),
						new paper.Size(chargeSize, chargeSize),
					),
				).map(p => path.intersect(p));
				let chargePart = calcShieldPart(charge, chargePaths.shift()! as paper.Path, targetParts, fessPoint);
				if(!targetParts || targetParts.includes(charge)) { // add paths for features
					for(let featureIdx in chargePaths) {
						let featurePaths = applyTincture(
							chargePaths[featureIdx] as paper.Path,
							charge.featureTinctures[featureIdx] ?? charge.field.tincture
						);
						chargePart.push(...featurePaths);
					}
				}
				chargePathMap.set(charge, chargePart);
			}
		}
	}
	// ordinaries
	let ordinaries = part.charges.filter(c => c.device.type == DeviceType.ordinary);
	for(let ordinary of ordinaries) {
		let halfWidth = path.bounds.width/8;
		if([DeviceId.bend, DeviceId.bendSinister, DeviceId.fess, DeviceId.pale].includes(ordinary.device.id)) {
			let div = getIntersectionPathForDivision(path, fessPoint, new Division(DivisionType.fess, ordinary.line));
			let ord = new paper.Path.Rectangle(new paper.Rectangle(new paper.Point(-200,-200), new paper.Size(400,400)));
			div.translate(new paper.Point(0, -halfWidth));
			ord = ord.subtract(div) as paper.Path;
			if([DivisionLine.engrailed, DivisionLine.invected].includes(ordinary.line)) {
				div.rotate(180, fessPoint);
				ord = ord.subtract(div) as paper.Path;
			} else if(ordinary.line != DivisionLine.embattled) {
				div.translate(new paper.Point(0, halfWidth*2));
				ord = ord.intersect(div) as paper.Path;
			} else {
				ord = ord.subtract(new paper.Path.Rectangle(
					new paper.Point(-200, fessPoint.y + halfWidth), new paper.Size(400,400),
				)) as paper.Path;
			}
			switch(ordinary.device.id) {
				case DeviceId.pale: {
					ord.rotate(90, fessPoint);
					break;
				}
				case DeviceId.bend: {
					ord.rotate(45, fessPoint);
					break;
				}
				case DeviceId.bendSinister: {
					ord.rotate(-45, fessPoint);
					break;
				}
			}
			chargePathMap.set(ordinary, calcShieldPart(ordinary, path.intersect(ord) as paper.Path, targetParts, fessPoint));
		} else if([DeviceId.chevron, DeviceId.chevronReversed].includes(ordinary.device.id)) {
			let reversed = DeviceId.chevronReversed == ordinary.device.id;
			let angles = [true, false].map(ex => {
				let angle = getRightAnglePathForLine(path, fessPoint, ordinary.line, ex);
				if(!reversed) {
					angle.scale(1, -1, fessPoint);
				}
				return angle;
			});
			let dist = halfWidth*2*(reversed ? 1 : -1);
			angles[1].translate(new paper.Point(0, dist));
			let chev = angles[1].subtract(angles[0]);
			chargePathMap.set(ordinary, calcShieldPart(
				ordinary, path.intersect(chev) as paper.Path, targetParts, new paper.Point(fessPoint.x, fessPoint.y + dist*.16)
			));
		} else if([DeviceId.cross, DeviceId.saltire].includes(ordinary.device.id)) {
			let angle = getRightAnglePathForLine(path, fessPoint, ordinary.line, true);
			angle.translate(new paper.Point(0, -halfWidth));
			if(DeviceId.cross == ordinary.device.id) {
				angle.rotate(-45, fessPoint);
			}
			let base = path.clone();
			for(let i=0; i<4; i++) {
				base = base.subtract(angle) as paper.Path;
				angle.rotate(90, fessPoint);
			}
			chargePathMap.set(ordinary, calcShieldPart(ordinary, base, targetParts, fessPoint));
		} else if([DeviceId.canton, DeviceId.quarter].includes(ordinary.device.id)) {
			let pt = fessPoint;
			if(DeviceId.canton == ordinary.device.id) {
				let size = Math.min(path.bounds.width, path.bounds.height) * .4;
				pt = new paper.Point(path.bounds.x + size, path.bounds.y + size);
			}
			let angle = getRightAnglePathForLine(path, pt, ordinary.line, false);
			angle.rotate(-45, pt);
			chargePathMap.set(ordinary, calcShieldPart(ordinary, path.intersect(angle) as paper.Path, targetParts, fessPoint));
		} else if([DeviceId.chief, DeviceId.base].includes(ordinary.device.id)) {
			let div = getIntersectionPathForDivision(path, fessPoint, new Division(DivisionType.fess, ordinary.line));
			if(DeviceId.chief == ordinary.device.id) {
				div.scale(1, -1, fessPoint);
			}
			let y = (fessPoint.y + (DeviceId.base == ordinary.device.id ? path.bounds.bottom : path.bounds.top)) / 2;
			div.translate(new paper.Point(0, y - fessPoint.y));
			chargePathMap.set(ordinary, calcShieldPart(ordinary, path.subtract(div) as paper.Path, targetParts, fessPoint));
		}
	}
	for(let c of part.charges) {
		paths.push(...(chargePathMap.get(c) ?? []));
	}
	return paths;
}

function calcShieldElements(shield: Part, targetParts: Part[]|null=null): PathData[] {
	let basePath = getPathForPart(shield, new paper.Rectangle(new paper.Point(-50, -50), new paper.Size(100, 100))).pop()!;
	let result = calcShieldPart(shield, basePath, targetParts);
	scope.project.clear();
	return result;
}
